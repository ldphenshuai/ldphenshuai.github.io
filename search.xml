<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大模型日志week02</title>
      <link href="/2024/09/09/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%97%A5%E5%BF%97week06/"/>
      <url>/2024/09/09/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%97%A5%E5%BF%97week06/</url>
      
        <content type="html"><![CDATA[<h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><h3 id="现有的一些微调方法"><a href="#现有的一些微调方法" class="headerlink" title="现有的一些微调方法"></a>现有的一些微调方法</h3><p>主流的方法包括2019年的Adapter Tuning，2021年微软提出的 LORA，斯坦福提出的Prefix-Tuning，谷歌提出的Prompt Tuning，2022年清华提出的P-tuning v2。</p><p>LoRa的效果会好于其它几种方法，其它方法存在一些问题：</p><ul><li>Adapter Tuning增加了模型层数，引入了额外的推理延迟</li><li>Prefix-Tuning难于训练，且预留给Prompt的序列挤占了下游任务的输入序列空间，影响模型性能</li><li>P-tuning v2很容易导致旧知识遗忘，微调之后的模型，在之前的问题上表现明显变差。</li></ul><p>假设模型在任务适配过程中权重的改变量是低秩的，LoRA 允许我们通过优化适应过程中密集层变化的秩分解矩阵，来间接训练神经网络中的一些密集层，同时保持预先训练的权重不变。</p><h3 id="LoRA微调"><a href="#LoRA微调" class="headerlink" title="LoRA微调"></a>LoRA微调</h3><p><code>LoRA(Low-Rank Adaptation)</code>微调冻结了预训练的模型权重，并将可训练的秩分解矩阵注入到 Transformer 架构的每一层，极大地减少了下游任务的可训练参数的数量。<br>下图为LoRA的示意图，左边蓝色部分是该方法会冻结的原始权重，右边是新增的微调权重模块，具体流程：<br><img src="/image-21.png" alt="alt text"></p><ol><li>在原始预训练语言模型旁边增加一个旁路，做降维再升维的操作来模拟内在秩；</li><li>用随机高斯分布初始化 A，用零矩阵初始化B，训练时固定预训练模型的参数，只训练矩阵 A 与矩阵 B ；</li><li>训练完成后，将 B 矩阵与 A 矩阵相乘后合并预训练模型参数作为微调后的模型参数。</li></ol><p>具体而言：</p><ol><li>基于 Transformer 结构，LoRA 只对每层的Self-Attention 的部分进行微调，有四个映射层参数可以进行微调。</li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后端日志-week06</title>
      <link href="/2024/09/09/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week06/"/>
      <url>/2024/09/09/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week06/</url>
      
        <content type="html"><![CDATA[<h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><h3 id="MySQL查询语句"><a href="#MySQL查询语句" class="headerlink" title="MySQL查询语句"></a>MySQL查询语句</h3><h4 id="查询结果去重"><a href="#查询结果去重" class="headerlink" title="查询结果去重"></a>查询结果去重</h4><p>使用Distinct和group by都能够实现去重的效果。</p><ol><li><code>distinct</code>只能放在查询字段的最前面，不能放在查询字段的中间或者后面。distinct 对后面所有的字段均起作用，即 去重是查询的所有字段完全重复的数据，而不是只对 distinct 后面连接的单个字段重复的数据。因此，Distinct查询多个字段只对一个字段去重是无法实现的。<code>SELECT DISTINCT university from user_profile;</code></li><li><code>group by</code>一般与聚类函数使用（如count()&#x2F;sum()等），也可单独使用。<code>group by</code>可以使查询结果按一个或者多个字段进行分组（查询的字段可以不等于group by的字段）,<code>SELECT university from user_profile GROUP BY university</code>;</li></ol><h4 id="查询结果限制返回行数"><a href="#查询结果限制返回行数" class="headerlink" title="查询结果限制返回行数"></a>查询结果限制返回行数</h4><ol><li>LIMIT n：从第0+1(m&#x3D;0)条开始，取n条数据，是LIMIT 0,n的缩写</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> device_id</span><br><span class="line"><span class="keyword">FROM</span> user_profile</span><br><span class="line">LIMIT <span class="number">2</span> </span><br></pre></td></tr></table></figure><ol start="2"><li>LIMIT m,n:从第m+1条开始，取n条数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> device_id</span><br><span class="line"><span class="keyword">FROM</span> user_profile</span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure><ol start="3"><li>LIMIT n OFFSET m:跳过前m条数据，从第m+1条开始取n条数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> device_id</span><br><span class="line"><span class="keyword">FROM</span> user_profile</span><br><span class="line">LIMIT <span class="number">2</span> <span class="keyword">OFFSET</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>tips : between是闭区间，包含了两个端点。</p></blockquote><h4 id="不等于的几种写法"><a href="#不等于的几种写法" class="headerlink" title="不等于的几种写法"></a>不等于的几种写法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,gender,age,university</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line">#<span class="keyword">where</span> university <span class="operator">!=</span> <span class="string">&#x27;复旦大学&#x27;</span></span><br><span class="line">#<span class="keyword">where</span> university <span class="operator">&lt;&gt;</span> <span class="string">&#x27;复旦大学&#x27;</span></span><br><span class="line">#<span class="keyword">where</span> university <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;复旦大学&#x27;</span></span><br><span class="line">#<span class="keyword">where</span> university <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;复旦大学&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="空值的过滤"><a href="#空值的过滤" class="headerlink" title="空值的过滤"></a>空值的过滤</h4><p>过滤空值的三种方法：<br>(1) Where 列名 is not null（推荐使用）<br>(2) Where 列名 !&#x3D; ‘null’<br>(3) Where 列名 &lt;&gt; ‘null’</p><h4 id="or的使用"><a href="#or的使用" class="headerlink" title="or的使用"></a>or的使用</h4><p>当查询列含有索引，使用or将会使索引失效，进行全表扫描，此时推荐使用UNION进行联合查询，二者各自走索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> `device_id`,`gender`,`age`,`university`,`gpa` <span class="keyword">FROM</span> `user_profile` <span class="keyword">WHERE</span> `university` <span class="operator">=</span> <span class="string">&#x27;北京大学&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> `device_id`,`gender`,`age`,`university`,`gpa` <span class="keyword">FROM</span> `user_profile` <span class="keyword">WHERE</span> `gpa`<span class="operator">&gt;</span><span class="number">3.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全表扫描</span></span><br><span class="line"><span class="keyword">select</span> device_id,gender,age,university,gpa <span class="keyword">from</span> user_profile <span class="keyword">where</span> gpa<span class="operator">&gt;</span><span class="number">3.7</span> <span class="keyword">or</span> university<span class="operator">=</span><span class="string">&#x27;北京大学&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="sql中的字符匹配"><a href="#sql中的字符匹配" class="headerlink" title="sql中的字符匹配"></a>sql中的字符匹配</h4><ol><li>_代表任意一个字符</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 学生表 <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;张__&#x27;</span><span class="operator">/</span><span class="operator">/</span>查询姓“张”且名字是<span class="number">3</span>个字的学生姓名。</span><br></pre></td></tr></table></figure><ol start="2"><li><p>% 代表任意数量（包括0个）的字符</p></li><li><p>[]匹配[]中的任意一个字符(若要比较的字符是连续的，则可以用连字符“-”表 达)，</p></li><li><p>[^ ] 不匹配[ ]中的任意一个字符</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 学生表 <span class="keyword">WHERE</span> 姓名 <span class="keyword">LIKE</span> <span class="string">&#x27;[张李刘]%&#x27;</span> <span class="comment">--查找姓张、李、刘</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 学生表 <span class="keyword">WHERE</span> 姓名 <span class="keyword">LIKE</span> <span class="string">&#x27;[^张李刘]%&#x27;</span> <span class="comment">--查找不姓张、李、刘</span></span><br></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>AVG()、COUNT()、SUM()、MAX()、MIN()、ROUND();<br>HAVING是在聚合函数之后，GROUP BY 之前的条件。主要用于过滤分组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--聚合函数应用经典案例</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="built_in">count</span>(gender) <span class="keyword">as</span> male_num,</span><br><span class="line">  round(<span class="built_in">avg</span>(gpa),<span class="number">1</span>) <span class="keyword">as</span> avg_gpa</span><br><span class="line"><span class="keyword">from</span> user_profile <span class="keyword">GROUP</span> <span class="keyword">BY</span> gender </span><br><span class="line"><span class="keyword">having</span> gender <span class="operator">=</span><span class="string">&#x27;male&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> gender,university,<span class="built_in">count</span>(gender) <span class="keyword">as</span> user_num,</span><br><span class="line"><span class="built_in">avg</span>(active_days_within_30) <span class="keyword">as</span> avg_active_days,<span class="built_in">avg</span>(question_cnt) <span class="keyword">as</span> avg_question_cnt</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">by</span> university,gender; <span class="comment">--考虑多列，多列一摸一样的分在一组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--聚合函数用Orderby排序</span></span><br><span class="line"><span class="keyword">SELECT</span> university,</span><br><span class="line"><span class="built_in">AVG</span>(question_cnt)  <span class="keyword">AS</span> avg_question_cnt</span><br><span class="line"><span class="keyword">FROM</span> user_profile</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> university</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(question_cnt) <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><h4 id="连接查询与子查询"><a href="#连接查询与子查询" class="headerlink" title="连接查询与子查询"></a>连接查询与子查询</h4><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p>Join和Inner Join是相同的，表示在表中存在至少一个匹配时返回行，相当于返回的是两个的交集。<br>LeftJoin从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li><code>A Inner Join B</code>：类似于取A和B的交集，只取满足条件的相交部分。</li><li><code>A Left Join B</code>：左连接，以左表A为基础，取A表的全部行，B满足On条件的取对应行，不满足的取NULL。</li><li><code>A Right Join B</code>：有连接，以右表B为基础，取B表的全部行，A满足On条件的取对应行，不满足的取NULL。</li><li><code>A Full Outer Join B</code>：类似于取A和B的并集。全都取，但彼此没有对应的值就取NULL。</li></ol><h5 id="在进行连接操作时where和on的区别"><a href="#在进行连接操作时where和on的区别" class="headerlink" title="在进行连接操作时where和on的区别"></a>在进行连接操作时where和on的区别</h5><ul><li>ON条件是在生成临时表时使用的条件，它不管ON中的条件是否满足，都会返回左表中的数据。</li><li>where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li></ul><blockquote><p>tips : 子查询返回多个值只能用<code>in</code>，确保只返回一个值可以用<code>=</code>。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 子查询方式</span></span><br><span class="line"><span class="keyword">select</span> device_id,question_id,<span class="keyword">result</span></span><br><span class="line"><span class="keyword">from</span> question_practice_detail</span><br><span class="line"><span class="keyword">where</span> device_id <span class="keyword">in</span> (</span><br><span class="line">     <span class="keyword">select</span> device_id</span><br><span class="line">     <span class="keyword">from</span> user_profile</span><br><span class="line">     <span class="keyword">where</span> university<span class="operator">=</span><span class="string">&#x27;浙江大学&#x27;</span></span><br><span class="line"> )</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> question_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Join方式</span></span><br><span class="line"><span class="keyword">select</span> q.device_id,q.question_id,q.result</span><br><span class="line"><span class="keyword">from</span> question_practice_detail q <span class="keyword">join</span> user_profile u <span class="keyword">on</span> q.device_id<span class="operator">=</span>u.device_id</span><br><span class="line"><span class="keyword">where</span> u.university<span class="operator">=</span><span class="string">&#x27;浙江大学&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> q.question_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 聚合函数和连接查询与having混用</span></span><br><span class="line"><span class="comment">-- 查看参加了答题的山东大学的用户在不同难度下的平均答题题目数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> u.university,q2.difficult_level,<span class="built_in">count</span>(q1.question_id)<span class="operator">/</span><span class="built_in">count</span>(<span class="keyword">distinct</span> q1.device_id)</span><br><span class="line"><span class="keyword">from</span> user_profile u</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> question_practice_detail q1</span><br><span class="line"><span class="keyword">ON</span> u.device_id<span class="operator">=</span>q1.device_id</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> question_detail q2</span><br><span class="line"><span class="keyword">on</span> q1.question_id<span class="operator">=</span>q2.question_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> u.university,q2.difficult_level</span><br><span class="line"><span class="keyword">having</span> u.university<span class="operator">=</span><span class="string">&#x27;山东大学&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="Union与Union-all的使用（or不走索引时，考虑Union）"><a href="#Union与Union-all的使用（or不走索引时，考虑Union）" class="headerlink" title="Union与Union all的使用（or不走索引时，考虑Union）"></a>Union与Union all的使用（or不走索引时，考虑Union）</h4><ul><li>结果集：<code>UNION</code>会在结果集中自动去除重复的行并会自动排序，会带来一定的性能开销。UNION ALL不会进行排序也不会去重，结果集顺序由各个子查询顺序决定，</li></ul><h4 id="IF、CASE-WHEN、COALESCE等函数的使用"><a href="#IF、CASE-WHEN、COALESCE等函数的使用" class="headerlink" title="IF、CASE WHEN、COALESCE等函数的使用"></a>IF、CASE WHEN、COALESCE等函数的使用</h4><p>IF语句和CASE WHEN语句通常用于根据某些条件返回不同值的函数。<br>if（x&#x3D;n,a,b）表示如果x&#x3D;n,则返回a，否则返回b。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IF下面返回两列，一列是25岁及以上，另一列是25岁以下。</span></span><br><span class="line"><span class="keyword">Select</span></span><br><span class="line">if(age<span class="operator">&gt;=</span><span class="number">25</span>,<span class="string">&#x27;25岁及以上&#x27;</span>,<span class="string">&#x27;25岁以下&#x27;</span> ) <span class="keyword">as</span> age_cut,</span><br><span class="line"><span class="built_in">count</span>(device_id) <span class="keyword">as</span> number</span><br><span class="line"><span class="keyword">From</span> user_profile</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">by</span> age_cut</span><br><span class="line"></span><br><span class="line"><span class="comment">--  CASE</span></span><br><span class="line"><span class="keyword">select</span> device_id,gender,</span><br><span class="line"><span class="keyword">case</span></span><br><span class="line">    <span class="keyword">when</span> age<span class="operator">&lt;</span><span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;20岁以下&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> age<span class="operator">&lt;</span><span class="number">25</span> <span class="keyword">then</span> <span class="string">&#x27;20-24岁&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">25</span> <span class="keyword">then</span> <span class="string">&#x27;25岁及以上&#x27;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="string">&#x27;其他&#x27;</span></span><br><span class="line"><span class="keyword">end</span> age_cut</span><br><span class="line"><span class="keyword">from</span> user_profile;</span><br></pre></td></tr></table></figure><h2 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h2><h3 id="Spring-WebFlux"><a href="#Spring-WebFlux" class="headerlink" title="Spring-WebFlux"></a>Spring-WebFlux</h3><h4 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h4><blockquote><p>tips : 受欢迎的web库Vertx完美支持协程，但在生态上并不好，不利于快速开发，协程对应响应式、Java&#x2F;Kotlin的响应式生态不完整，导致响应式无法被普遍使用，导致协程无法被广泛使用。（协程和异步响应式往往是对应的）</p></blockquote><blockquote><p>JDK1.8是基于Observer&#x2F;Observable接口而实现的观察者模式，JDK9及以后，Observer&#x2F;Observable接口就被弃用了，取而代之的是Flow类(juc包下面的Flow)。（采用发布者订阅者模式并在两者之间建立订阅关系）</p></blockquote><p>响应式流规范可以总结为4个接⼝：<code>Publisher、Subscriber、Subscription和Processor</code>。<code>Publisher</code>负责⽣成数据，并将数据发送给<code>Subscription</code>（每个<code>Subscriber</code>对应⼀个<code>Subscription</code>）。一旦<code>Subscriber</code>订阅成功，就可以接收来⾃<code>Publisher</code>的事件。Publisher调⽤ onSubscribe() ⽅法时,会将Subscription对象传递给Subscriber。通过Subscription，Subscriber可以管理其订阅情况。Subscriber开始请求数据后，数据就会开始流经响应流，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面发布者订阅者相关类都是juc包下面的flow类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowDemo2</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 定义发布者, 发布的数据类型是 Integer</span></span><br><span class="line">        <span class="comment">// 直接使用jdk自带的SubmissionPublisher</span></span><br><span class="line">        SubmissionPublisher&lt;Integer&gt; publiser = <span class="keyword">new</span> <span class="title class_">SubmissionPublisher</span>&lt;Integer&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2. 定义处理器, 对数据进行过滤, 并转换为String类型</span></span><br><span class="line">        <span class="type">MyProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyProcessor</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 3. 发布者 和 处理器 建立订阅关系</span></span><br><span class="line">        publiser.subscribe(processor);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4. 定义最终订阅者, 消费 String 类型数据</span></span><br><span class="line">        Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;String&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription subscription)</span> &#123;</span><br><span class="line">                <span class="comment">// 保存订阅关系, 需要用它来给发布者响应</span></span><br><span class="line">                <span class="built_in">this</span>.subscription = subscription;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 请求一个数据</span></span><br><span class="line">                <span class="built_in">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(String item)</span> &#123;</span><br><span class="line">                <span class="comment">// 接受到一个数据, 处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;接受到数据: &quot;</span> + item);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 处理完调用request再请求一个数据</span></span><br><span class="line">                <span class="built_in">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 或者 已经达到了目标, 调用cancel告诉发布者不再接受数据了</span></span><br><span class="line">                <span class="comment">// this.subscription.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                <span class="comment">// 出现了异常(例如处理数据的时候产生了异常)</span></span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 我们可以告诉发布者, 后面不接受数据了</span></span><br><span class="line">                <span class="built_in">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 全部数据处理完了(发布者关闭了)</span></span><br><span class="line">                System.out.println(<span class="string">&quot;处理完了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 5. 处理器 和 最终订阅者 建立订阅关系</span></span><br><span class="line">        processor.subscribe(subscriber);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 6. 生产数据, 并发布</span></span><br><span class="line">        <span class="comment">// 这里忽略数据生产过程</span></span><br><span class="line">        publiser.submit(-<span class="number">111</span>);</span><br><span class="line">        publiser.submit(<span class="number">111</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 7. 结束后 关闭发布者</span></span><br><span class="line">        <span class="comment">// 正式环境 应该放 finally 或者使用 try-resouce 确保关闭</span></span><br><span class="line">        publiser.close();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 主线程延迟停止, 否则数据没有消费就退出</span></span><br><span class="line">        Thread.currentThread().join(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Reactor项目的Flux和Mono"><a href="#Reactor项目的Flux和Mono" class="headerlink" title="Reactor项目的Flux和Mono"></a>Reactor项目的Flux和Mono</h4><p><code>Flux</code>和<code>Mono</code>都是数据流的发布者，使用<code>Flux</code>和<code>Mono</code>都可以发出三种数据信号：<strong>元素值、错误信号、完成信号</strong>，错误信号和完成信号都代表终止信号，终止信号用于告诉订阅者数据流结束了，错误信号终止数据流同时把错误信息传递给订阅者。</p><blockquote><p>tips : Mono和Flux的很多操作都是相同的，二者处理的数据量不同。Flux返回N个元素，Mono返回0或1个元素。Flux适用于处理多个元素，Mono适用于处理只有一个或没有元素的情况。</p></blockquote><p><img src="/image-22.png" alt="alt text"><br><a href="https://blog.csdn.net/A_art_xiang/article/details/129578800">Flux和Mono的相关操作</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; characterFlux = Flux</span><br><span class="line">        .just(<span class="string">&quot;Garfield&quot;</span>, <span class="string">&quot;Kojak&quot;</span>, <span class="string">&quot;Barbossa&quot;</span>)</span><br><span class="line">        .delayElements(Duration.ofMillis(<span class="number">500</span>)); <span class="comment">// 每500毫秒发布⼀个数据</span></span><br><span class="line"></span><br><span class="line">Flux&lt;String&gt; foodFlux = Flux</span><br><span class="line">        .just(<span class="string">&quot;Lasagna&quot;</span>, <span class="string">&quot;Lollipops&quot;</span>, <span class="string">&quot;Apples&quot;</span>)</span><br><span class="line">        .delaySubscription(Duration.ofMillis(<span class="number">250</span>)) <span class="comment">// 订阅后250毫秒后开始发布数据</span></span><br><span class="line">        .delayElements(Duration.ofMillis(<span class="number">500</span>)); <span class="comment">// 每500毫秒发布⼀个数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使⽤mergeWith()⽅法，将两个Flux合并，合并过后的Flux数据项发布顺序与源Flux的发布时间⼀致</span></span><br><span class="line"><span class="comment">// Garfield Lasagna Kojak Lollipops Barbossa Apples</span></span><br><span class="line">Flux&lt;String&gt; mergedFlux = characterFlux.mergeWith(foodFlux);</span><br><span class="line"></span><br><span class="line">mergedFlux.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞，等待结果</span></span><br><span class="line">Thread.sleep(<span class="number">100000</span>);</span><br></pre></td></tr></table></figure><h4 id="异步机制"><a href="#异步机制" class="headerlink" title="异步机制"></a>异步机制</h4><h5 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h5><p><strong>事件轮询机制</strong>在多个事件源或输入源之间检测和处理事件。轮询机制不断检查是否有新的事件发生，并根据检测到的事件作出相应处理。与事件驱动机制不同，事件轮询通过主动查询的方式来获取事件的状态，而不是等待事件自动触发。</p><p>工作流程：</p><ul><li>创建一个轮询器，并为它指定一个或多个事件源（如文件、网络套接字、定时器等）。</li><li>在循环中不断查询事件源的状态，检查是否有事件发生。</li><li>一旦检测到事件，立即调用相应的处理程序来处理该事件。</li></ul><p>例如：程序启动后，初始化一个轮询器，用来检测多个客户端的连接。轮询器不断轮询客户端的连接状态，检测是否有新的请求。如果某个客户端有请求数据到达，轮询器立即调用对应的函数处理该请求。处理完之后继续轮询。</p><h5 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h5><h6 id="1-NIO的非阻塞I-O模型"><a href="#1-NIO的非阻塞I-O模型" class="headerlink" title="1.NIO的非阻塞I&#x2F;O模型"></a>1.NIO的非阻塞I&#x2F;O模型</h6><ul><li>在传统的阻塞I&#x2F;O中，程序通常需要为每一个客户端连接创建一个线程，每个线程阻塞等待I&#x2F;O操作完成（例如读或写操作）。这种模型在高并发场景下效率较低，因为线程数量的增加会导致大量的上下文切换和资源消耗。</li><li>NIO 提供了一种非阻塞模式，程序不必阻塞等待 I&#x2F;O 操作完成。它允许在单个线程中管理多个通道（Channel），从而极大地提升了性能。</li></ul><h6 id="2-Selector与事件轮询"><a href="#2-Selector与事件轮询" class="headerlink" title="2.Selector与事件轮询"></a>2.Selector与事件轮询</h6><ul><li>NIO的核心组件之一是<code>Selector</code>，它就是事件轮询机制的一个实现。<br><code>Selector</code>允许程序同时监控多个通道（如网络套接字）的状态。程序通过 <code>Selector</code>注册多个通道，然后可以在事件发生时轮询这些通道，处理其中的I&#x2F;O事件（如可读、可写等）。</li><li>Selector 内部使用类似于操作系统提供的select()、poll()或epoll()等系统调用实现事件轮询机制，监听通道的状态变化。</li></ul><h6 id="3-具体工作流程"><a href="#3-具体工作流程" class="headerlink" title="3.具体工作流程"></a>3.具体工作流程</h6><ul><li><strong>事件注册</strong>：Selector可以注册多个<code>Channel</code>，并指定关注的事件类型（如READ、WRITE等）。</li><li><strong>事件轮询</strong>：Selector进入轮询循环，通过操作系统底层的事件轮询机制不断检查通道上是否有事件发生。</li><li><strong>事件处理</strong>：当检测到有通道上有事件发生时，<code>Selector</code>将返回相应的事件，程序会调用相应的事件处理逻辑来处理这些I&#x2F;O事件。</li></ul><h6 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h6><p>NIO的<code>Selector</code>是Java中事件轮询机制的核心实现，依赖底层操作系统提供的 select()、poll() 或 epoll() 等机制来高效地管理大量 I&#x2F;O 通道的状态。通过事件轮询机制，NIO 能够在单个线程中处理多个I&#x2F;O事件，从而显著提升高并发场景下的性能和资源利用率。</p><h5 id="select-、poll-和-epoll"><a href="#select-、poll-和-epoll" class="headerlink" title="select()、poll() 和 epoll()"></a>select()、poll() 和 epoll()</h5><h6 id="1-select"><a href="#1-select" class="headerlink" title="1.select()"></a>1.select()</h6><ul><li>select() 通过将需要监控的文件描述符集合传递给内核，内核遍历这些文件描述符，检查它们是否可读、可写或者有异常发生。</li><li>程序调用 select() 函数并传入一组文件描述符，内核会阻塞该调用，直到其中至少有一个文件描述符变为可用（如可读或可写），或超时发生。</li><li>文件描述符通过三个<code>fd_set</code>集合来表示，分别用于<strong>读、写和异常事件</strong>的检测。</li></ul><p><strong>底层实现：</strong><br>select() 依赖于位图（bitmap）来表示每个文件描述符的状态。其实现方式是在每次调用时，遍历所有文件描述符，检查它们的状态变化。当事件发生时，内核更新位图并返回给用户空间程序。</p><p><strong>不足:</strong></p><ul><li>文件描述符的数量有上限：通常为1024。</li><li>每次调用select() 时，<strong>用户空间和内核空间之间需要复制文件描述符集合</strong>，这会导致性能瓶颈。</li><li>select()会遍历整个文件描述符集合，即使只有少数几个文件描述符有事件发生，这种线性扫描会导致效率低下。</li></ul><h6 id="2-poll"><a href="#2-poll" class="headerlink" title="2.poll()"></a>2.poll()</h6><ul><li>不同于<code>select()</code>使用位图表示文件描述符，<code>poll()</code>使用一个结构体数组**pollfd[]**来保存每个文件描述符及其感兴趣的事件。</li><li>和<code>select()</code>一样，<code>poll()</code>的检查过程也是每次都会遍历整个文件描述符集合。</li><li><code>poll()</code>会在用户空间和内核空间之间复制一个<code>pollfd</code>结构数组(所以每次调用poll时也会在用户态和内核态之间复制)，然后内核通过线性扫描检查每个文件描述符是否有事件发生。</li><li><code>poll()</code>是水平触发的，即当某个文件描述符的状态改变后，如果不处理它，则每次调用<code>poll()</code>都会通知该文件描述符的状态变化。</li></ul><h6 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3.epoll()"></a>3.epoll()</h6><p><strong>工作原理：</strong></p><ul><li><code>epoll()</code>是Linux专有的I&#x2F;O多路复用机制，是 select() 和 poll() 的改进版本。它在处理大量并发连接时效率更高，特别适合高并发场景。</li><li><code>epoll()</code>除水平触发机制外，还有边缘触发：只在文件描述符的状态从不可用变为可用时才会通知程序。</li></ul><p><strong>底层实现：</strong></p><ul><li><strong>事件注册机制：</strong> <code>epoll()</code>首次调用时，用户通过<code>epoll_create()</code>创建一个<code>epoll</code>实例，然后通过<code>epoll_ctl()</code>将要监控的文件描述符注册到这个实例中。与<code>select()</code>和<code>poll()</code>每次调用时都需要传递文件描述符不同，<code>epoll()</code>将文件描述符注册一次，后续就可以直接通过事件通知机制来获取I&#x2F;O事件。</li><li><strong>内核事件队列：</strong> <code>epoll</code>通过一个内核级事件队列来监控文件描述符的状态。当某个文件描述符有事件发生时，内核将该事件加入队列中，然后用户空间通过<code>epoll_wait()</code>来获取已发生的事件。</li><li><code>epoll</code>使用<strong>红黑树</strong>来管理文件描述符，以实现高效的增删操作,事件发生时，内核将事件加入双向链表中，避免了遍历整个文件描述符集合。</li></ul><h6 id="区别总结："><a href="#区别总结：" class="headerlink" title="区别总结："></a>区别总结：</h6><p><img src="/image-23.png" alt="alt text"></p><h4 id="Spring-WebFlux对响应式编程（异步）的支持"><a href="#Spring-WebFlux对响应式编程（异步）的支持" class="headerlink" title="Spring WebFlux对响应式编程（异步）的支持"></a>Spring WebFlux对响应式编程（异步）的支持</h4><blockquote><p>tips: WebFlux的默认嵌⼊式服务器是Netty⽽不是Tomcat。Netty是⼀个异步、事件驱动的服务器，⾮常适合Spring WebFlux这样的反应式Web框架。</p></blockquote><p>传统的基于Servlet的Web框架，如Spring MVC,在本质上都是阻塞和多线程的，每个连接都会使用一个线程。在请求处理的时候，会在线程池中拉取一个工作者( worker )线程来对请求进行处理。同时，请求线程是阻塞的，直到工作者线程提示它已经完成为止。</p><p>在Spring5中，引入了一个新的<strong>异步、非阻塞的WEB</strong>模块，就是Spring-WebFlux。该框架在很大程度上是<strong>基于Reactor项目</strong>的，能够解决Web应用和API中对更好的可扩展性的需求。</p><p>异步的Web框架能够以更少的线程获得更⾼的可扩展性，通常它们只需要与CPU核⼼数量相同的线程。通过使⽤所谓的事件轮询（event looping）机制，这些框架能够⽤⼀个线程处理很多请求，这样每次连接的成本会更低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟数据库存储</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, User&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">()</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lisi&quot;</span>));</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;wangwu&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查询</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">getById</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="comment">// 返回数据或空值</span></span><br><span class="line">        <span class="keyword">return</span> Mono.justOrEmpty(map.get(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询多个</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Flux.fromIterable(map.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">save</span><span class="params">(Mono&lt;User&gt; userMono)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMono.doOnNext(user -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> map.size() + <span class="number">1</span>;</span><br><span class="line">            map.put(id, user);</span><br><span class="line">        &#125;).thenEmpty(Mono.empty()); <span class="comment">// 最后置空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SpirngWebFlux一般用于SpringCloud-Gateway网关，用于处理请求、路由转发等功能。</strong></p><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>在try-with-resources内的资源，需要释放的资源（比如 BufferedReader）实现了 AutoCloseable接口。</p><h2 id="day06"><a href="#day06" class="headerlink" title="day06"></a>day06</h2><h3 id="使用枚举类的方法"><a href="#使用枚举类的方法" class="headerlink" title="使用枚举类的方法"></a>使用枚举类的方法</h3><p>直接枚举类名.加上枚举字段名加上get方法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后端日志-week05</title>
      <link href="/2024/09/02/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week05/"/>
      <url>/2024/09/02/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week05/</url>
      
        <content type="html"><![CDATA[<h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><h3 id="HttpServlet中的service方法"><a href="#HttpServlet中的service方法" class="headerlink" title="HttpServlet中的service方法"></a>HttpServlet中的service方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取http request的method参数，其实就是html的form标签  </span></span><br><span class="line">        <span class="comment">//中method属性对应的字符串 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        <span class="type">long</span> errMsg;</span><br><span class="line">        <span class="comment">//判断请求方式</span></span><br><span class="line">        <span class="keyword">if</span>(method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//获取最后被修改时间 </span></span><br><span class="line">            errMsg = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span>(errMsg == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="comment">/**如果servlet不支持http request header的if-modified-since属性 </span></span><br><span class="line"><span class="comment">             * 则继续处理 </span></span><br><span class="line"><span class="comment">             **/</span>  </span><br><span class="line">                <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果支持这个属性 </span></span><br><span class="line">                <span class="type">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(<span class="string">&quot;If-Modified-Since&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                    ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">/** </span></span><br><span class="line"><span class="comment">                * 如果客户端的文件最后修改时间和服务器端的文件最后修改时间一致则返回304不需要修改状态 </span></span><br><span class="line"><span class="comment">                * 这样服务器就不返回html，浏览器读取本地缓存文件，否则重新获取服务器端的对应html文件 </span></span><br><span class="line"><span class="comment">                **/</span>  </span><br><span class="line">                <span class="keyword">if</span>(ifModifiedSince &lt; errMsg / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.maybeSetLastModified(resp, errMsg);</span><br><span class="line">                    <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">            errMsg = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="built_in">this</span>.maybeSetLastModified(resp, errMsg);</span><br><span class="line">            <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果请求不是以上的所有请求方式，该方法就会响应501错误，也就是不支持这种请求</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg1</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;method&#125;;</span><br><span class="line">            errMsg1 = MessageFormat.format(errMsg1, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg1);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把ServletRequest和Response转成Http请求和响应</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        HttpServletRequest request;</span><br><span class="line">        HttpServletResponse response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request = (HttpServletRequest)req;</span><br><span class="line">            response = (HttpServletResponse)res;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips : HEAD: 与GET类似，但服务器在响应中只返回HTTP头部。<br>Options: 允许客户端查看服务器支持的HTTP方法。<br>Trace: 回显服务器接收到的请求。</p></blockquote><h3 id="java后端中的响应式编程"><a href="#java后端中的响应式编程" class="headerlink" title="java后端中的响应式编程"></a>java后端中的响应式编程</h3><h4 id="响应式编程的基石-响应流"><a href="#响应式编程的基石-响应流" class="headerlink" title="响应式编程的基石-响应流"></a>响应式编程的基石-响应流</h4><ul><li>响应流必须无阻塞</li><li>响应流必须是一个数据流</li><li>必须可以异步执行</li><li>处理背压（生产者可以感受到消费者反馈的消费压力，并根据压力进行动态调整生产速率）</li></ul><h4 id="Publiher"><a href="#Publiher" class="headerlink" title="Publiher"></a>Publiher</h4><p>由于响应流的特点，我们不能再返回一个简单的POJO对象来表示结果了。必须返回一个类似Java中的Future的概念，在有结果可用时通知消费者进行消费响应。</p><p>Reactive Stream规范中这种被定义为<code>Publisher&lt;T&gt;</code> ，<code>Publisher&lt;T&gt;</code>是一个可以提供0-N个序列元素的提供者，并根据其订阅者<code>Subscriber&lt;? super T&gt;</code>的需求推送元素。一个<code>Publisher&lt;T&gt;</code>可以支持多个订阅者，并可以根据订阅者的逻辑进行推送序列元素。下面这个Excel计算就能说明一些<code>Publisher&lt;T&gt;</code>的特点。</p><p><img src="/image-17.png" alt="alt text"></p><p>A1-A9就可以看做<code>Publisher&lt;T&gt;</code>及其提供的元素序列。<code>A10-A13</code>分别是求和函数<code>SUM(A1:A9)</code>、平均函数<code>AVERAGE(A1:A9)</code>、最大值函数<code>MAX(A1:A9)</code>、最小值函数<code>MIN(A1:A9)</code>，可以看作订阅者<code>Subscriber</code>。</p><h4 id="Flux和Mono的处理方式"><a href="#Flux和Mono的处理方式" class="headerlink" title="Flux和Mono的处理方式"></a><a href="https://www.cnblogs.com/felordcn/p/13747262.html">Flux和Mono的处理方式</a></h4><h3 id="网关的GlobalExcetionHandler"><a href="#网关的GlobalExcetionHandler" class="headerlink" title="网关的GlobalExcetionHandler"></a>网关的GlobalExcetionHandler</h3><blockquote><p>tips : ServerWebExchange是Spring WebFlux框架中用于表示HTTP请求和响应的接口。ServerWebExchange接口提供了一组方法来访问HTTP请求和响应的相关信息，包括请求头、请求体、响应头和响应体等。它还提供了一些方法来操作请求和响应，例如设置或获取请求头、请求体、响应头和响应体等。</p></blockquote><h4 id="OKHttpClient"><a href="#OKHttpClient" class="headerlink" title="OKHttpClient"></a>OKHttpClient</h4><p>OKHttp是一个高效的HTTP客户端，具有以下默认特性：</p><ul><li>支持HTTP&#x2F;2，允许所有同一个主机地址的请求共享同一个socket连接</li><li>连接池减少请求延时</li><li>透明的GZIP压缩减少响应数据的大小</li><li>缓存响应内容，避免一些完全重复的请求</li></ul><p>配置的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> HttpConfig httpConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有实例化RestTemplate时，初始化RestTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(RestTemplate.class)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>(getClientHttpRequestFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用OkHttpClient作为底层客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ClientHttpRequestFactory <span class="title function_">getClientHttpRequestFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                .connectTimeout(httpConfig.getConnTimeout(), TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(httpConfig.getWriteTimeout(), TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(httpConfig.getReadTimeout(), TimeUnit.SECONDS)</span><br><span class="line">                .sslSocketFactory(SSLSocketConfig.getSSLSocketFactory(), SSLSocketConfig.getX509TrustManager())</span><br><span class="line">                .hostnameVerifier(SSLSocketConfig.getHostnameVerifier())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OkHttp3ClientHttpRequestFactory</span>(okHttpClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h2><h3 id="MySQL相关查询语句"><a href="#MySQL相关查询语句" class="headerlink" title="MySQL相关查询语句"></a>MySQL相关查询语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> table_name; <span class="comment">--查看表结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> your_table_name</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">FIRST</span>; <span class="comment">--将ID列移动到第一行</span></span><br></pre></td></tr></table></figure><h3 id="实体类映射工具MapStruct"><a href="#实体类映射工具MapStruct" class="headerlink" title="实体类映射工具MapStruct"></a>实体类映射工具MapStruct</h3><blockquote><p>tips : MapStruct的注解也是Mapper，此时导入的包是<code>org.mapstruct.Mapper</code>，而非Mybatis的包。</p></blockquote><p>在后端开发中一般会将实体类经过转换后（DO-&gt;RespVO(DTO)）才返回给前端，前端提交过来的对象也需要经过转换Entity实体才做存储；通常使用的BeanUtils.copyProperties方法也比较粗暴，不仅效率低下（使用反射）而且仅映射相同名的属性，多数情况下还需要手动编写对应的转换方法实现。</p><p>插件MapStruct以接口方法结合注解优雅实现对象转换，MapStruct生成器生成代码以更贴近原生的Setter、Getter方法处理属性映射更为高效。</p><h4 id="简单用例"><a href="#简单用例" class="headerlink" title="简单用例"></a>简单用例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserConvert</span> &#123;</span><br><span class="line">    <span class="type">UserConvert</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> Mappers.getMapper(UserConvert.class);</span><br><span class="line">    <span class="meta">@Mapping(source = &quot;name&quot;, target = &quot;userName&quot;)</span> <span class="comment">//这个注解不写也可以，只有当字段名称不一样的时候需要手动写</span></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;username&quot;, ignore = true)</span> <span class="comment">//表示忽略字段</span></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;createdAt&quot;, expression = &quot;java(java.time.LocalDateTime.now())&quot;)</span> <span class="comment">//也可以映射常量</span></span><br><span class="line">    UserVO <span class="title function_">toVO</span><span class="params">(User entity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">0</span>, <span class="string">&quot;Tester&quot;</span>, <span class="number">1</span>, <span class="string">&quot;上海市徐汇区&quot;</span>);</span><br><span class="line">    <span class="type">UserVO</span> <span class="variable">userVO</span> <span class="operator">=</span> UserConvert.INSTANCE.toVO(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linux开机自启动jar包的流程"><a href="#linux开机自启动jar包的流程" class="headerlink" title="linux开机自启动jar包的流程"></a>linux开机自启动jar包的流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line"><span class="comment">#在文件中添加以下内容,表示开机后100秒后执行后面的命令</span></span><br><span class="line"><span class="comment">#其中/home/dmx/dmxStartup.sh是执行启动jar包的shell脚本</span></span><br><span class="line"></span><br><span class="line">@reboot <span class="built_in">sleep</span> 100 &amp;&amp; /home/dmx/dmxStartup.sh</span><br></pre></td></tr></table></figure><h2 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h2><h3 id="Redis相关知识"><a href="#Redis相关知识" class="headerlink" title="Redis相关知识"></a>Redis相关知识</h3><h4 id="引入Lua脚本的目的"><a href="#引入Lua脚本的目的" class="headerlink" title="引入Lua脚本的目的"></a>引入Lua脚本的目的</h4><ol><li>保证原子性<br>在 Redis 中，所有的 Lua 脚本是作为一个原子操作执行的。换句话说，在脚本执行期间，Redis 不会处理其他客户端的命令。</li><li>减少网络延迟<br>Redis 是一个基于客户端-服务器的系统，每个命令都需要客户端与服务器之间进行一次通信。如果一个复杂的操作需要多个命令，频繁的网络通信会导致延迟。通过 Lua 脚本，可以将多个命令合并到一个脚本中发送给服务器，减少网络往返次数，从而提高性能。</li><li>执行复杂逻辑和操作灵活性<br>Lua 脚本提供了一种在 Redis 服务器端编写复杂逻辑的方法，允许在执行 Redis 命令时加入条件判断、循环等控制结构。</li></ol><h4 id="在SpringBoot项目中使用Lua脚本"><a href="#在SpringBoot项目中使用Lua脚本" class="headerlink" title="在SpringBoot项目中使用Lua脚本"></a>在SpringBoot项目中使用Lua脚本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用lua脚本保证操作原子性</span></span><br><span class="line">        stringRedisTemplate.execute(UNLOCK_SCRIPT</span><br><span class="line">                , Collections.singletonList(KET_PREFIX+name)</span><br><span class="line">                ,ID_PREFIX+Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Redis的key分类形式"><a href="#Redis的key分类形式" class="headerlink" title="Redis的key分类形式"></a>Redis的key分类形式</h4><p><img src="/image-18.png" alt="alt text"></p><h2 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h2><blockquote><p>tips : @TableId注解默认是自增的</p></blockquote><p>和下列配置有关：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment"># 虽然默认为 true ，但是还是显示去指定下。</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">NONE</span> <span class="comment"># “智能”模式，基于 IdTypeEnvironmentPostProcessor + 数据源的类型，自动适配成 AUTO、INPUT 模式。</span></span><br><span class="line">      <span class="comment">#      id-type: AUTO # 自增 ID，适合 MySQL 等直接自增的数据库</span></span><br><span class="line">      <span class="comment">#      id-type: INPUT # 用户输入 ID，适合 Oracle、PostgreSQL、Kingbase、DB2、H2 数据库</span></span><br><span class="line">      <span class="comment">#      id-type: ASSIGN_ID # 分配 ID，默认使用雪花算法。注意，Oracle、PostgreSQL、Kingbase、DB2、H2 数据库时，需要去除实体类上的 @KeySequence 注解</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">$&#123;travel.info.base-package&#125;.dal.dataobject</span> <span class="comment"># travel.info.base-package在dal(mysql)包下面</span></span><br></pre></td></tr></table></figure><h2 id="day05"><a href="#day05" class="headerlink" title="day05"></a>day05</h2><blockquote><p>tips: <a href="https://blog.csdn.net/SUMMERENT/article/details/129587241">MybatisX快速生成接口、实体类以及xml的操作</a></p></blockquote><h3 id="在后端项目中，先建库还是先建表"><a href="#在后端项目中，先建库还是先建表" class="headerlink" title="在后端项目中，先建库还是先建表"></a>在后端项目中，先建库还是先建表</h3><ul><li>如果你的项目规模较大、数据库设计较为复杂，可以先设计 MySQL 数据表，确保数据结构清晰、稳定。</li><li>如果你正在开发一个相对灵活或敏捷的项目，且使用了 ORM 工具，则可以先创建实体类，通过代码生成数据库表。<br>对于很多现代 Java 后端项目，开发者往往选择先创建实体类，然后通过 ORM 工具自动生成数据库表的方式，灵活应对业务变化，并且可以减少维护工作。</li></ul><h3 id="根据实体类自动建表的方案（JPA）"><a href="#根据实体类自动建表的方案（JPA）" class="headerlink" title="根据实体类自动建表的方案（JPA）"></a>根据实体类自动建表的方案（JPA）</h3><p>在连接数据库的时候会自动创建，（其实感觉写完实体类，让chatgpt帮你写下sql建表也行。）</p><h4 id="1-导入JPA依赖与配置"><a href="#1-导入JPA依赖与配置" class="headerlink" title="1.导入JPA依赖与配置"></a>1.导入JPA依赖与配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--MySQL依赖 用于jdbc连接--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">&lt;!--jpa依赖 自动建表--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!--mybatis依赖 用于操作数据库的crud,可以不用到，若是业务需要可以改为mybatis--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JPA配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;!--配置数据库连接与jpa的yml配置--&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?userSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">                <span class="comment">#create----每次运行该程序，没有表格会新建表格，表内有数据会清空</span></span><br><span class="line">                <span class="comment">#create-drop----每次程序结束的时候会清空表</span></span><br><span class="line">                <span class="comment">#update----每次运行程序，没有表格会新建表格，表内有数据不会清空，只会更新</span></span><br><span class="line">                <span class="comment">#validate----运行程序会校验数据与数据库的字段类型是否相同，不同会报错</span></span><br><span class="line">      <span class="attr">dialect:</span> <span class="string">org.hibernate.dialect.MySQL5InnoDBDialect</span></span><br></pre></td></tr></table></figure><h4 id="2-创建实体类"><a href="#2-创建实体类" class="headerlink" title="2.创建实体类"></a>2.创建实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;demo_user&quot;)</span></span><br><span class="line"><span class="meta">@TableName(&quot;demo_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;userid&quot;,columnDefinition = &quot;int comment &#x27;主键ID&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column(name = &quot;age&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Column(name = &quot;email&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Column(name = &quot;phone&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-注解属性"><a href="#3-注解属性" class="headerlink" title="3. 注解属性"></a>3. 注解属性</h4><p><img src="/image-19.png" alt="alt text"></p><h3 id="建表时候的要求"><a href="#建表时候的要求" class="headerlink" title="建表时候的要求"></a>建表时候的要求</h3><ol><li>表名：见名知意，如user_name;</li><li>大小写：尽量都使用小写字母；</li><li>分隔符：尽量不使用空格和特殊字符，数据库名、表名和列名之间用下划线分隔；</li><li>字段名称：见名知意，尽量避免用不容易理解的缩写或拼音，统一字段，比如状态都用status</li><li>普通索引和联合索引用ix_前缀，唯一索引用ux_前缀。</li><li>字段类型：根据业务尽量选占用存储小的字段类型</li><li>字段长度：varchar和char类型长度为字符长度，其余类型代表的都是字节长度。</li><li>字段个数：每张表<strong>不超过20个字段</strong>，复杂的拆成多张表。</li><li>NOT NULL：在定义字段时，尽量明确该字段是否Not Null。因为在innodb中，需要额外空间存储NULL值；其次NULL值可能会导致索引失效；最后NULL值只能用is null或者is not null判断，“&#x3D;&#x3D;”判断永远返回False</li><li>外键：互联网系统中一般不设置外键。</li><li>时间字段：<strong>优先使用datetime字段</strong>，其保存时间范围更大。</li><li>索引：在经常查询的字段上建立索引，同时也考虑索引的数量和长度，避免影响性能，<strong>单表索引数量不超过5个</strong></li><li>唯一索引：<strong>使用频率很高</strong>，一般在不怎么更新的字段上加唯一索引（比如部门、机构等），创建唯一索引时，<strong>相关字段不能出现NULL值</strong>，不然唯一索引会失效。</li><li>大字段：如用户评论等，不建议使用text、blob类型（定义VarChar类型比较合理），可以考虑拆表或者存储在其他地方。</li></ol><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><h4 id="唯一索引特点"><a href="#唯一索引特点" class="headerlink" title="唯一索引特点"></a>唯一索引特点</h4><ul><li>唯一索引的值必须是唯一的，不允许重复。</li><li>唯一索引可以提高数据的访问速度，因为Mysql会对唯一索引进行优化。</li><li>唯一索引可以通过UNIQUE INDEX关键词在表中指定，也可以在创建表之后使用ALTER TABLE语句添加唯一索引。</li></ul><h4 id="唯一索引使用场景"><a href="#唯一索引使用场景" class="headerlink" title="唯一索引使用场景"></a>唯一索引使用场景</h4><p>唯一索引适合用于需要保证数据列唯一性的情况，例如用户表中的邮箱字段。唯一索引可以避免插入重复的数据，保证数据的一致性和准确性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大模型日志week02</title>
      <link href="/2024/08/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%97%A5%E5%BF%97week04/"/>
      <url>/2024/08/29/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%97%A5%E5%BF%97week04/</url>
      
        <content type="html"><![CDATA[<h2 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h2><h3 id="LoRA微调"><a href="#LoRA微调" class="headerlink" title="LoRA微调"></a>LoRA微调</h3><p>大模型微调的步骤：在选定相关数据集和预训练模型的基础上，通过设置合适的超参数并对模型进行必要的调整，使用特定任务的数据对模型进行训练以优化其性能。</p><h4 id="微调的四个步骤"><a href="#微调的四个步骤" class="headerlink" title="微调的四个步骤"></a>微调的四个步骤</h4><ul><li>数据处理：选择与任务相关的数据集，对数据集进行预处理。</li><li>模型加载：将预训练的大模型导入。</li><li>设置模型微调参数：加载预训练的大模型，使用新的任务数据对其进行微调，包括设定学习率，训练轮次，批次大小等。</li><li><img src="/image-15.png" alt="alt text"></li></ul><h4 id="大模型微调流程-RLHF（Reinforcement-Learning-from-Human-Feedback）"><a href="#大模型微调流程-RLHF（Reinforcement-Learning-from-Human-Feedback）" class="headerlink" title="大模型微调流程-RLHF（Reinforcement Learning from Human Feedback）"></a>大模型微调流程-RLHF（Reinforcement Learning from Human Feedback）</h4><p>RLHF（Reinforcement Learning from Human Feedback）：一种利用人类反馈作为奖励信号来训练强化学习模型的方法，旨在提升模型生成文本等内容的质量，使其更符合人类偏好。<br>强化学习（Reinforcement Learning）结合人类反馈（Human Feedback）来微调大语言模型（Large Language Models）的一般过程：</p><h5 id="1-使用监督数据微调语言模型"><a href="#1-使用监督数据微调语言模型" class="headerlink" title="1. 使用监督数据微调语言模型"></a>1. 使用监督数据微调语言模型</h5><p>这一步与传统的fine-tuning类似，即使用标注过的数据来调整预训练模型的参数，使其更好地适应特定任务或领域。</p><h5 id="2-训练奖励模型"><a href="#2-训练奖励模型" class="headerlink" title="2. 训练奖励模型"></a>2. 训练奖励模型</h5><ul><li>奖励模型用于评估文本序列的质量，它接受一个文本作为输入，并输出一个数值，表示该文本符合人类偏好的程度。</li><li>训练数据通常由多个语言模型生成的文本序列组成，这些序列经过人工评估或使用其他模型（如ChatGPT）进行打分。</li></ul><p><img src="/image-16.png" alt="alt text"></p><h5 id="3-训练RL模型"><a href="#3-训练RL模型" class="headerlink" title="3. 训练RL模型"></a>3. 训练RL模型</h5><p>在强化学习框架中，需要定义状态空间、动作空间、策略函数和价值函数。策略函数就是经过微调的大语言模型，它根据当前状态选择下一个动作。</p><h4 id="微调应用"><a href="#微调应用" class="headerlink" title="微调应用"></a>微调应用</h4><ol><li><p>全量微调<br>全量微调利用特定任务数据调整预训练模型的所有参数，以充分适应新任务。它依赖大规模计算资源，但能有效利用预训练模型的通用特征。</p></li><li><p>参数高效微调（Parameter-Efficient Fine-Tuning, PEFT）<br>PEFT旨在通过最小化微调参数数量和计算复杂度，实现高效的迁移学习。它仅更新模型中的部分参数，显著降低训练时间和成本，适用于计算资源有限的情况。PEFT技术包括Prefix Tuning、Prompt Tuning、Adapter Tuning等多种方法，可根据任务和模型需求灵活选择。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运营平台后端代码详解</title>
      <link href="/2024/08/26/%E8%BF%90%E8%90%A5%E5%B9%B3%E5%8F%B0%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/08/26/%E8%BF%90%E8%90%A5%E5%B9%B3%E5%8F%B0%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="运营平台后端"><a href="#运营平台后端" class="headerlink" title="运营平台后端"></a>运营平台后端</h3><blockquote><p>tips ：server.servlet.context-path用于指定Web应用程序的上下文路径，例如，如果你设置server.servlet.context-path&#x3D;&#x2F;myapp，那么当用户访问<a href="http://localhost:8080/myapp">http://localhost:8080/myapp</a>时，Boot应用程序会处理这个请求。<br>tips : 写dev&#x2F;local&#x2F;prod这类配置的时候，可以把你的nacos相关配置写到最上面，后面直接变量名引用就行，例如：</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">large:</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.46</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">large-model-dev</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">LARGE_MODEL_GROUP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用方式 $&#123;large.model.nacos.server-addr&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>tips : <code>META-INF/spring.factories</code>文件用于自动配置和扩展Spring应用程序。这个文件通过Spring的工厂加载机制，可以自动发现和加载配置类、监听器等组件，从而实现模块化和自动化配置。当你在Config包下面写了一些配置时，可以通过以下方式配置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.pubinfo.large.model.framework.dict.config.TravelDictRpcAutoConfiguration,\</span><br><span class="line">  com.pubinfo.large.model.framework.dict.config.TravelDictAutoConfiguration</span><br></pre></td></tr></table></figure><h4 id="Async的基本使用"><a href="#Async的基本使用" class="headerlink" title="@Async的基本使用"></a>@Async的基本使用</h4><p>@Async注解可以让被标注的方法异步执行，但是有前提条件</p><ol><li>配置类上添加@EnableAsync注解开启对异步方法的支持。</li><li>异步执行的方法所在类由Spring管理，即类上要注解@Component或者其他能将类添加到Spring IOC容器的注解。</li></ol><p>由于Async注解使用的默认线程池不会复用线程，因此最好使用自定义的线程池。</p><ol><li>使用AsyncConfigurer指定线程池，用于全局配置线程池的核心接口。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@EnableAsync</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalAsyncConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">5</span>); <span class="comment">// 核心线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>); <span class="comment">// 最大线程数</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">20</span>); <span class="comment">// 队列容量</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;global-&quot;</span>); <span class="comment">// 线程名称前缀</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在Spring容器中注册一个线程池bean，这种方式能按需使用线程池资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPoolConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name = &quot;customExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">customExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">5</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">10</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;custom-&quot;</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法，在@Async注解中写Bean的名字</span></span><br><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Async(&quot;customExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCustomTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此方法将使用CustomThreadPoolConfig中名为customExecutor的线程池执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运营平台重写Servlet和SpringCloudGateWay的目的"><a href="#运营平台重写Servlet和SpringCloudGateWay的目的" class="headerlink" title="运营平台重写Servlet和SpringCloudGateWay的目的"></a>运营平台重写Servlet和SpringCloudGateWay的目的</h4><p>为了统计日志信息，统计大模型响应成功率与响应速度，校验安全策略，限制访问频次。需要搭建自己的网关，在网关中对于上游服务的请求进行记录与统计。</p><p>其主要实现在<code>LargeModelServlet</code>、<code>ServerInvokeLogServiceImpl</code>和<code>LargeModelServiceImpl</code>类中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后端日志-week3</title>
      <link href="/2024/08/26/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week04/"/>
      <url>/2024/08/26/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week04/</url>
      
        <content type="html"><![CDATA[<h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><h3 id="在IDEA中Debug"><a href="#在IDEA中Debug" class="headerlink" title="在IDEA中Debug"></a>在IDEA中Debug</h3><p>断点处右键可以设置条件，当满足条件时，才会停止到当行。</p><h3 id="玩转Stream流"><a href="#玩转Stream流" class="headerlink" title="玩转Stream流"></a>玩转Stream流</h3><blockquote><p><strong>Stream</strong>将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如：筛选、排序、聚合等。</p></blockquote><h4 id="Stream对流的两种操作"><a href="#Stream对流的两种操作" class="headerlink" title="Stream对流的两种操作"></a>Stream对流的两种操作</h4><ol><li>中间操作，每次返回一个新的流，可以有多个。（筛选filter、映射map、排序sorted、去重组合skip—limit）</li><li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。（遍历foreach、匹配find–match、规约reduce、聚合max–min–count、收集collect）</li></ol><h4 id="Stream特性"><a href="#Stream特性" class="headerlink" title="Stream特性"></a>Stream特性</h4><ol><li>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</li><li>stream不会改变数据源，通常情况下会产生一个新的集合或一个值。</li><li>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li></ol><h4 id="Stream与传统遍历对比"><a href="#Stream与传统遍历对比" class="headerlink" title="Stream与传统遍历对比"></a>Stream与传统遍历对比</h4><p>几乎所有的集合（如 Collection 接口或 Map 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。</p><ul><li>传统遍历方式与流式遍历：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1List</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;殷离&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; listA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( String s  : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                listA.add(s);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; listB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s: listA) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length() == <span class="number">3</span>)</span><br><span class="line">                listB.add(s);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (String s: listB) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//流式遍历,可以</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                .filter(name -&gt; name.length() == <span class="number">3</span>)</span><br><span class="line">                .forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环遍历明显看出很繁杂，而流式遍历步骤简单，一步到位。</li></ul><h4 id="Stream的创建"><a href="#Stream的创建" class="headerlink" title="Stream的创建"></a>Stream的创建</h4><p><code>Stream</code>可以通过集合或数组创建。</p><h5 id="1-通过java-util-Collection-stream-方法用集合创建流"><a href="#1-通过java-util-Collection-stream-方法用集合创建流" class="headerlink" title="1. 通过java.util.Collection.stream()方法用集合创建流"></a>1. 通过<code>java.util.Collection.stream()</code>方法用集合创建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 创建一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"><span class="comment">// 创建一个并行流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br></pre></td></tr></table></figure><h5 id="2-通过java-util-Collection-stream-方法用集合创建流"><a href="#2-通过java-util-Collection-stream-方法用集合创建流" class="headerlink" title="2. 通过java.util.Collection.stream()方法用集合创建流"></a>2. 通过<code>java.util.Collection.stream()</code>方法用集合创建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(array);</span><br></pre></td></tr></table></figure><h5 id="stream和parallelStream的简单区分"><a href="#stream和parallelStream的简单区分" class="headerlink" title="stream和parallelStream的简单区分"></a>stream和parallelStream的简单区分</h5><p>stream是顺序流，由主线程按顺序对流执行操作，而parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如二者在筛选集合中奇数的处理方式不同：</p><p><img src="/image-11.png" alt="alt text"></p><h4 id="Stream流的使用"><a href="#Stream流的使用" class="headerlink" title="Stream流的使用"></a>Stream流的使用</h4><blockquote><p>Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。(<strong>用以接受Stream筛选后的元素</strong>)</p></blockquote><h5 id="遍历-筛选"><a href="#遍历-筛选" class="headerlink" title="遍历&#x2F;筛选"></a>遍历&#x2F;筛选</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import已省略，请自行添加，后面代码亦是</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 遍历输出符合条件的元素</span></span><br><span class="line">       list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).forEach(System.out::println);</span><br><span class="line">       <span class="comment">// 匹配第一个</span></span><br><span class="line">       Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).findFirst();</span><br><span class="line">       <span class="comment">// 匹配任意（适用于并行流）</span></span><br><span class="line">       Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; <span class="number">6</span>).findAny();</span><br><span class="line">       <span class="comment">// 是否包含符合特定条件的元素</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> list.stream().anyMatch(x -&gt; x &gt; <span class="number">6</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;匹配第一个值：&quot;</span> + findFirst.get());</span><br><span class="line">       System.out.println(<span class="string">&quot;匹配任意一个值：&quot;</span> + findAny.get());</span><br><span class="line">       System.out.println(<span class="string">&quot;是否存在大于6的值：&quot;</span> + anyMatch);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>筛选出员工中工资高于8000的员工姓名并形成新的集合，形成新集合依赖collect：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">  personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; filterList = personList.stream().filter(x -&gt; x.getSalary() &gt; <span class="number">8000</span>).map(Person::getName).collect(Collectors.toList()); <span class="comment">//map在流式处理中将元素转换为另一个形式，比如这里转化为姓名</span></span><br><span class="line">  System.out.print(<span class="string">&quot;高于8000的员工姓名：&quot;</span> + filterList);</span><br><span class="line"></span><br><span class="line">  Optional&lt;Person&gt; max = personList.stream().max(Comparator.comparingInt(Person::getSalary));</span><br><span class="line">  System.out.println(<span class="string">&quot;员工工资最大值：&quot;</span> + max.get().getSalary());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">9</span>);</span><br><span class="line">  <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).count();</span><br><span class="line">  System.out.println(<span class="string">&quot;list中大于6的元素个数：&quot;</span> + count);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="聚合（max-min-count）"><a href="#聚合（max-min-count）" class="headerlink" title="聚合（max&#x2F;min&#x2F;count）"></a>聚合（max&#x2F;min&#x2F;count）</h5><ol><li>获取String集合中最长的元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;adnm&quot;</span>, <span class="string">&quot;admmt&quot;</span>, <span class="string">&quot;pot&quot;</span>, <span class="string">&quot;xbangd&quot;</span>, <span class="string">&quot;weoujgsd&quot;</span>);</span><br><span class="line">  Optional&lt;String&gt; max = list.stream().max(Comparator.comparing(String::length));</span><br><span class="line">  System.out.println(<span class="string">&quot;最长的字符串：&quot;</span> + max.get());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>获取Integer集合中的最大值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自然排序</span></span><br><span class="line">  Optional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);</span><br><span class="line">  <span class="comment">// 自定义排序</span></span><br><span class="line">  Optional&lt;Integer&gt; max2 = list.stream().max(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  System.out.println(<span class="string">&quot;自然排序的最大值：&quot;</span> + max.get());</span><br><span class="line">  System.out.println(<span class="string">&quot;自定义排序的最大值：&quot;</span> + max2.get());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="映射（map、flatMap）"><a href="#映射（map、flatMap）" class="headerlink" title="映射（map、flatMap）"></a>映射（map、flatMap）</h5><p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为map和flatMap（<strong>map往往后面跟着的是collect，意味着要收集成新元素</strong>）：</p><ul><li><code>map</code>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li><li><code>flatMap</code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</li></ul><p>代码案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  String[] strArr = &#123; <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;bcdd&quot;</span>, <span class="string">&quot;defde&quot;</span>, <span class="string">&quot;fTr&quot;</span> &#125;;</span><br><span class="line">  List&lt;String&gt; strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">  List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>);</span><br><span class="line">  List&lt;Integer&gt; intListNew = intList.stream().map(x -&gt; x + <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;每个元素大写：&quot;</span> + strList);</span><br><span class="line">  System.out.println(<span class="string">&quot;每个元素+3：&quot;</span> + intListNew);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给每位员工增加1000薪资</span></span><br><span class="line"><span class="comment">// 改变原来员工集合的方式</span></span><br><span class="line">  List&lt;Person&gt; personListNew2 = personList.stream().map(person -&gt; &#123;</span><br><span class="line">   person.setSalary(person.getSalary() + <span class="number">10000</span>);</span><br><span class="line">   <span class="keyword">return</span> person;</span><br><span class="line">  &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="规约（reduce）"><a href="#规约（reduce）" class="headerlink" title="规约（reduce）"></a>规约（reduce）</h5><p>归约，也称缩减，即把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="comment">// 求和方式1</span></span><br><span class="line">  Optional&lt;Integer&gt; sum = list.stream().reduce((x, y) -&gt; x + y);</span><br><span class="line">  <span class="comment">// 求和方式2</span></span><br><span class="line">  Optional&lt;Integer&gt; sum2 = list.stream().reduce(Integer::sum);</span><br><span class="line">  <span class="comment">// 求和方式3</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">sum3</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 求乘积</span></span><br><span class="line">  Optional&lt;Integer&gt; product = list.stream().reduce((x, y) -&gt; x * y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求最大值方式1</span></span><br><span class="line">  Optional&lt;Integer&gt; max = list.stream().reduce((x, y) -&gt; x &gt; y ? x : y);</span><br><span class="line">  <span class="comment">// 求最大值写法2</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">max2</span> <span class="operator">=</span> list.stream().reduce(<span class="number">1</span>, Integer::max);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;list求和：&quot;</span> + sum.get() + <span class="string">&quot;,&quot;</span> + sum2.get() + <span class="string">&quot;,&quot;</span> + sum3);</span><br><span class="line">  System.out.println(<span class="string">&quot;list求积：&quot;</span> + product.get());</span><br><span class="line">  System.out.println(<span class="string">&quot;list求和：&quot;</span> + max.get() + <span class="string">&quot;,&quot;</span> + max2);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">sumSalary2</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.getSalary(),Integer::sum); <span class="comment">//(reduce(0,(sum, p) -&gt; sum += p.getSalary(),表示从0开始收集，后面是一个lambda方法，表示统计薪资集合)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="收集（Collect）"><a href="#收集（Collect）" class="headerlink" title="收集（Collect）"></a>收集（Collect）</h5><p>因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。<code>toList</code>、<code>toSet</code>和<code>toMap</code>比较常用。</p><h4 id="Stream流总结内容-后续还有排序-sorted-等内容"><a href="#Stream流总结内容-后续还有排序-sorted-等内容" class="headerlink" title="Stream流总结内容,后续还有排序(sorted)等内容"></a><a href="https://blog.csdn.net/qq_43410878/article/details/123716629">Stream流总结内容,后续还有排序(sorted)等内容</a></h4><h2 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>比较器的Lambda写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(people, (o1, o2) -&gt; o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? o1[<span class="number">1</span>] - o2[<span class="number">1</span>]: o2[<span class="number">0</span>] - o1[<span class="number">0</span>]); <span class="comment">//二维数组</span></span><br><span class="line">Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]); <span class="comment">//二维数组</span></span><br></pre></td></tr></table></figure><h3 id="SpringBoot单元测试"><a href="#SpringBoot单元测试" class="headerlink" title="SpringBoot单元测试"></a>SpringBoot单元测试</h3><h4 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h4><p>当一个测试满足下面任意一点，就不是单元测试</p><ol><li>与数据库&#x2F;网络&#x2F;文件系统交流</li><li>不能与其他单元测试同一时间运行</li><li>不能特意为单元测试做特别的事情</li></ol><h4 id="微服务中单元测试（开发者测试）"><a href="#微服务中单元测试（开发者测试）" class="headerlink" title="微服务中单元测试（开发者测试）"></a><a href="https://blog.csdn.net/significantfrank/article/details/137495244">微服务中单元测试（开发者测试）</a></h4><p>微服务中先从对外接口开始测，这样做可以用尽量少的测试代码，覆盖更多的功能逻辑，测试效率高。其次是我们可以在保证接口不变的情况下，对内部逻辑进行重构，重构效率高（“粗粒度测试”）。</p><h4 id="依赖问题的解决"><a href="#依赖问题的解决" class="headerlink" title="依赖问题的解决"></a>依赖问题的解决</h4><p>对于分布式微服务系统而言，“粗粒度单元测试”最大挑战在于如何解决周边依赖问题，对于一个典型的应用而言，它可能会依赖数据库、消息中间件、缓存系统等，以及周边的其它服务。</p><h5 id="Mock做替身"><a href="#Mock做替身" class="headerlink" title="Mock做替身"></a>Mock做替身</h5><p>框架比如Mockito，EasyMock支持去做mock的事情，比如对于常见的数据库依赖，我们可以通过如下的方式去mock（基于Mockito框架）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个模拟的 UserRepository</span></span><br><span class="line">        <span class="type">UserRepository</span> <span class="variable">userRepositoryMock</span> <span class="operator">=</span> mock(UserRepository.class);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建一个 UserService 实例，将模拟的 UserRepository 传入</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(userRepositoryMock);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 设置模拟的 UserRepository 的行为</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">expectedUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">        expectedUser.setAge(<span class="number">35</span>);</span><br><span class="line">        expectedUser.setSex(<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        expectedUser.setEducation(<span class="string">&quot;doctor&quot;</span>);</span><br><span class="line">        when(userRepositoryMock.getUserById(<span class="number">1</span>)).thenReturn(expectedUser);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 调用 UserService 的方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">actualUser</span> <span class="operator">=</span> userService.getUserById(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 验证模拟的 UserRepository 的方法是否被正确调用</span></span><br><span class="line">        verify(userRepositoryMock).getUserById(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 断言返回的用户是否符合预期</span></span><br><span class="line">        assertEquals(expectedUser, actualUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="EmbeddedServer做替身"><a href="#EmbeddedServer做替身" class="headerlink" title="EmbeddedServer做替身"></a>EmbeddedServer做替身</h5><p>比如我用到了Redis缓存，那么我可以使用embedded-redis启动一个本地的redis，从而连接到“真实”的redis环境。使用的话只需要加入下面的依赖。在Junit5的Extension帮助下，我们可以很优雅的使用embedded的服务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.codemonstur<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>embedded-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h2><h3 id="Dynamic与Druid中的多数据源配置与应用"><a href="#Dynamic与Druid中的多数据源配置与应用" class="headerlink" title="Dynamic与Druid中的多数据源配置与应用"></a>Dynamic与Druid中的多数据源配置与应用</h3><p>pom导入依赖后，如果有多数据源，要写如下的配置文件：</p><h4 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;datasource1&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.druid.datasource1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean(name = &quot;datasource2&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.druid.datasource2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主数据源配置"><a href="#主数据源配置" class="headerlink" title="主数据源配置"></a>主数据源配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.ais.cdc.mapper&quot;&#125;, sqlSessionFactoryRef = &quot;sqlSessionFactoryDs1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisMasterConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;datasource1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DataSource datasource1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactoryDs1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MybatisSqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisSqlSessionFactoryBean</span>();</span><br><span class="line">        factoryBean.setDataSource(datasource1);</span><br><span class="line">        factoryBean.setMapperLocations(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(<span class="string">&quot;classpath:/mapper/*.xml&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//向Mybatis过滤器链中添加拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        factoryBean.setPlugins(interceptor);</span><br><span class="line">        <span class="keyword">return</span> factoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">sqlSessionTemplateDs1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactoryDs1());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(datasource1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从数据源的配置"><a href="#从数据源的配置" class="headerlink" title="从数据源的配置"></a>从数据源的配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.ais.cdc.mapper2&quot;&#125;, sqlSessionFactoryRef = &quot;sqlSessionFactoryDs2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisSlaveConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;datasource2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DataSource datasource2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactoryDs2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MybatisSqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisSqlSessionFactoryBean</span>();</span><br><span class="line">        factoryBean.setDataSource(datasource2);</span><br><span class="line">        factoryBean.setMapperLocations(</span><br><span class="line">                <span class="comment">//设置mybatis的xml所在位置</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(<span class="string">&quot;classpath:/mapper2/*.xml&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> factoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">sqlSessionTemplateDs2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactoryDs2());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(datasource2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_43859729/article/details/112171048">配置后相关报错问题</a></p><h3 id="IO多路复用机制，select-epoll原理"><a href="#IO多路复用机制，select-epoll原理" class="headerlink" title="IO多路复用机制，select&#x2F;epoll原理"></a>IO多路复用机制，select&#x2F;epoll原理</h3><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大模型日志week02</title>
      <link href="/2024/08/19/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%97%A5%E5%BF%97week02/"/>
      <url>/2024/08/19/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%97%A5%E5%BF%97week02/</url>
      
        <content type="html"><![CDATA[<h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><ul><li><input checked="" disabled="" type="checkbox"> 了解当下大语言模型</li></ul><h3 id="大模型架构"><a href="#大模型架构" class="headerlink" title="大模型架构"></a>大模型架构</h3><h4 id="1-MoE-混合专家模型-："><a href="#1-MoE-混合专家模型-：" class="headerlink" title="1. MoE(混合专家模型)："></a>1. <strong>MoE(混合专家模型)：</strong></h4><p>MOE是把大问题先做拆分，再逐个解决小问题，再汇总结论。模型规模是提升模型性能的关键因素之一，在有限的计算资源下，用更少的训练步数训练一个更大的模型，往往比用更多的步数训练一个较小的模型效果更佳。<br>MoE正是基于上述的理念，它由多个专业化的子模型（即“专家”）组合而成，专家的混合不会节省任何计算，因为前向传播仍然需要评估每个专家，而反向传播也必须接触每个专家，但是我们可以选择由哪些专家进行回答并规范化，这代表在前向和反向传播时，只需要使用非0的专家。</p><h4 id="2-基于检索的模型"><a href="#2-基于检索的模型" class="headerlink" title="2. 基于检索的模型:"></a>2. <strong>基于检索的模型:</strong></h4><h5 id="检索增强生成的工作流程"><a href="#检索增强生成的工作流程" class="headerlink" title="检索增强生成的工作流程"></a>检索增强生成的工作流程</h5><ol><li><strong>检索：</strong><br> 首先，我们需要进行的是检索过程。在这个阶段，我们利用用户的查询内容，从外部知识源获取相关信息。具体来说，就是将用户的查询通过嵌入模型转化为向量，这样就可以与向量数据库中的其他上下文信息进行比对。通过这种相似性搜索，我们可以找到向量数据库中最匹配的前k个数据。</li><li><strong>增强：</strong><br> 接下来，我们进入增强阶段。在这个阶段，我们将用户的查询和检索到的额外信息一起嵌入到一个预设的提示模板中。这个过程的目的是为了提供更丰富、更具上下文的信息，以便于后续的生成过程。</li><li><strong>生成：</strong><br> 最后，我们进行生成过程。在这个阶段，我们将经过检索增强的提示内容输入到大语言模型（LLM）中，以生成所需的输出。这个过程是RAG的核心，它利用了LLM的强大生成能力，结合了前两个阶段的信息，生成了准确、丰富且与上下文相关的输出。</li></ol><h5 id="Naive-RAG"><a href="#Naive-RAG" class="headerlink" title="Naive RAG"></a>Naive RAG</h5><ol><li><strong>Indexing(离线处理)：</strong></li></ol><ul><li>从各种格式（PDF、HTML、Markdown、Word 等）的额外语料库中提取纯文本内容。</li><li>由于LLM上下文窗口的限制，比如常见的2K、4K，需要将提取的文本内容切分为不同的 chunks。</li><li>使用文本 embedding 模型，针对每个chunk提取相应的文本embedding。</li><li>将文本 embedding 和对应的 chunk 存储为索引，能一一对应，即生成chunk-embedding。</li></ul><ol start="2"><li><strong>在线处理：</strong></li></ol><ul><li>Retrieval（在线处理）：</li><li>使用文本 embedding 模型，针对用户 query 提取 query embedding。</li><li>使用query embedding 与索引中的 chunk embedding 进行比对，找到最相似的 k 个 embedding。然后提取 k 个最相似 embedding 对应的 chunk。</li><li>Generation（在线处理）：</li><li>将 query 与检索到的 chunks 进行合并，将合并后的Query输入到LLM中以生成结果。</li></ul><p>RAG 是一种通过<strong>检索外部知识库</strong>(其实主要优化就是对这个知识库进行优化，提高知识粒度与检索过程优化等)来获得额外语料，并使用 ICL（In-Context-Learning，上下文学习）来改进 LLM 生成效果的范式。</p><p><img src="/image-9.png" alt="alt text"></p><h4 id="2-1-Advanced-RAG-在Navive-RAG的基础上做了增强"><a href="#2-1-Advanced-RAG-在Navive-RAG的基础上做了增强" class="headerlink" title="2.1 Advanced RAG(在Navive RAG的基础上做了增强)"></a>2.1 Advanced RAG(在Navive RAG的基础上做了增强)</h4><h5 id="2-1-1-Pre-Retrieval-Proess-检索前优化"><a href="#2-1-1-Pre-Retrieval-Proess-检索前优化" class="headerlink" title="2.1.1 Pre-Retrieval Proess(检索前优化)"></a>2.1.1 Pre-Retrieval Proess(检索前优化)</h5><ul><li>增强数据粒度：旨在提升文本标准化、一致性、事实准确性和丰富的上下文，以提高 RAG 系统的性能。比如删除不相关的信息、消除实体和数据中的歧义、更新过时文档等。</li><li>优化索引结构：调整块的大小以捕获相关上下文、跨多个索引路径进行查询。</li><li>混合检索：主要是指充分利用关键词检索、语义检索、向量检索等其他检索技术来提升检索丰富度，同时也可以保证一致性。</li></ul><h5 id="2-1-2-Post-Retrieval-Process"><a href="#2-1-2-Post-Retrieval-Process" class="headerlink" title="2.1.2 Post-Retrieval Process"></a>2.1.2 Post-Retrieval Process</h5><p>检索到的内容比较多，重要性也各不相同，如果一味地和 query 合并可能会超过 LLM 上下文限制，同时增加计算开销，也可能引入噪声，导致生成质量不佳。此时，通常需要对检索到的内容进一步处理：</p><ul><li>重排序（Re-Ranking）：这是搜索领域非常常见的手段，不过在传统搜索中通常是按相关性、质量等进行排序输出；而在 LLM 生成领域要考虑检索到文档的多样性，以及 LLM 对 Prompt 中内容所在位置的敏感度等，比如 LostInTheMiddleRanker 将最佳文档交替地放在上下文窗口的开头和结尾。</li><li>提示压缩（Prompt Compression）：有研究表明，检索到的文档中的噪声会对 RAG 性能产生不利影响。在后处理中，可以重点压缩不相干的上下文，突出关键段落，减少整体上下文长度。也可以用专门的模型对文档进行压缩、总结、过滤等。</li></ul><h5 id="Graph-RAG-知识图谱和RAG的结合，效果很好"><a href="#Graph-RAG-知识图谱和RAG的结合，效果很好" class="headerlink" title="Graph-RAG (知识图谱和RAG的结合，效果很好)"></a>Graph-RAG (知识图谱和RAG的结合，效果很好)</h5><p>当外部知识库为知识图谱（Neo4j存储），结合向量 + 关键字和图检索方法（被称为混合检索）。</p><p><strong>总结：</strong></p><ul><li>为了扩大模型规模，需要改进稠密Transformer。</li><li>混合专家和基于检索的方法相结合更有效。</li><li>如何设计更好的、可扩展的体系结构仍然是一个悬而未决的问题。</li></ul><h3 id="大模型之Adaptation"><a href="#大模型之Adaptation" class="headerlink" title="大模型之Adaptation"></a>大模型之Adaptation</h3><h4 id="为什么需要语言模型的Adaptation"><a href="#为什么需要语言模型的Adaptation" class="headerlink" title="为什么需要语言模型的Adaptation?"></a>为什么需要语言模型的Adaptation?</h4><p>下游任务与语言模型的训练任务之间的不同之处非常复杂。这些差异可以从格式、主题和时间三个方面来探讨，每个方面都可能涉及许多具体的挑战和需求。通过深入了解这些不同之处，我们可以更好地理解如何有效地适配语言模型以满足各种下游任务的需求。</p><ol><li>格式：</li></ol><ul><li><strong>自然语言推理（NLI）</strong>: 下游任务如NLI涉及两个句子的比较以产生单一的二进制输出。这与语言模型通常用于生成下一个标记或填充MASK标记的任务截然不同。例如，NLI的逻辑推理过程涉及多层次的比较和理解，而不仅仅是根据给定的上下文生成下一个可能的词。</li></ul><ol start="2"><li>主题转变：</li></ol><ul><li><strong>特定领域的需求</strong>: 下游任务可能集中在特定的主题或领域上，例如医疗记录分析或法律文档解析。这些任务可能涉及专门的术语和知识，与模型的通用训练任务相去甚远。</li></ul><ol start="3"><li>时间转变</li></ol><ul><li><strong>新知识的需求</strong>: 随着时间的推移，新的信息和知识不断涌现。例如，GPT-3在拜登成为总统之前就已训练完毕，因此可能缺乏有关他总统任期的最新信息。</li><li><strong>非公开信息的需求</strong>: 有时下游任务可能涉及在训练期间不公开的信息。这可能需要更多特定领域的专业知识和调整。</li></ul><h4 id="微调模型适应任务"><a href="#微调模型适应任务" class="headerlink" title="微调模型适应任务"></a>微调模型适应任务</h4><h5 id="通用的Adaptation配置"><a href="#通用的Adaptation配置" class="headerlink" title="通用的Adaptation配置"></a>通用的Adaptation配置</h5><ol><li><p><strong>预训练语言模型（Pre-trained LM）</strong>:<br>在适配阶段的开始，我们已经有了一个预训练的语言模型，用参数$θLM$表示。这个模型被训练来理解和生成语言，但不是特别针对任何特定任务。</p></li><li><p><strong>下游任务数据集（Downstream Task Dataset）</strong>:<br>我们获得了一组来自下游任务分布$P_{task}$的样本数据。这些数据可以是文本分类、情感分析等任务的特定实例，每个样本由输入x和目标输出y组成，如：$\left(x^{(1)}, y^{(1)}\right), \ldots,\left(x^{(n)}, y^{(n)}\right)$。</p></li><li><p><strong>适配参数（Adaptation Parameters）</strong>:<br>为了使预训练的LM适合特定的下游任务，我们需要找到一组参数$\gamma$，这组参数可以来自现有参数的子集或引入的新的参数，$\Gamma$。这些参数将用于调整模型，以便它在特定任务上的表现更好。</p></li><li><p><strong>任务损失函数（Task Loss Function）</strong>:<br>我们需要定义一个损失函数$\ell_{\text {task }}$来衡量模型在下游任务上的表现。例如，交叉熵损失是一种常见的选择，用于衡量模型预测的概率分布与真实分布之间的差异。</p></li><li><p><strong>优化问题（Optimization Problem）</strong>:<br>我们的目标是找到一组适配参数$\gamma_{\text {adapt }}$，使得任务损失在整个下游数据集上最小化。数学上，这可以通过以下优化问题表示</p></li></ol><p>通过这个过程，我们可以取得一组适配参数$\gamma_{\text {adapt }}$，用于参数化适配后的模型$p_{adapt}$。这样，我们就可以将通用的、任务无关的预训练语言模型适配到特定的下游任务上，以实现更好的性能。这种适配方法将模型的通用性与特定任务的效能结合在一起，既保留了模型的灵活性，又确保了在特定任务上的高效表现。</p><h5 id="主流的Adaptation方法"><a href="#主流的Adaptation方法" class="headerlink" title="主流的Adaptation方法"></a>主流的Adaptation方法</h5><h5 id="1-fine-tuning"><a href="#1-fine-tuning" class="headerlink" title="1. fine-tuning"></a>1. fine-tuning</h5><p>Fine-tuning（微调）使用语言模型参数$θLM$作为优化的初始化。其中，优化后的参数家族$\Gamma$包括了所有的语言模型参数和任务特定的预测头参数。与此同时，预训练的优化器状态被丢弃。</p><p><a href="https://blog.csdn.net/qq_39172059/article/details/136693607">大模型微调步骤</a></p><h5 id="2-大模型开发工具"><a href="#2-大模型开发工具" class="headerlink" title="2. 大模型开发工具"></a>2. 大模型开发工具</h5><ol><li>Hugging Face</li></ol><ul><li>提供多种 NLP 任务的模型库，如语言翻译、文本生成和问答。</li><li>提供了在特定数据集上微调预训练模型的工具。</li><li>提供了访问和利用应用程序中预训练模型的 API。</li><li>提供了构建定制模型并将其部署到云端的工具。</li><li>提供大量预训练的NLP模型。</li></ul><ol start="2"><li>LangChain<br>LangChain 是一个用于开发由语言模型驱动的应用程序的框架。我们相信，最强大和不同的应用程序不仅将通过 API 调用语言模型，还将：</li></ol><ul><li>数据感知：将语言模型与其他数据源连接在一起。</li><li>主动性：允许语言模型与其环境进行交互</li></ul><h2 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h2><h3 id="LangChain详解"><a href="#LangChain详解" class="headerlink" title="LangChain详解"></a>LangChain详解</h3><h4 id="LangChain组成"><a href="#LangChain组成" class="headerlink" title="LangChain组成"></a>LangChain组成</h4><p>LangChain 包含六部分组成，分别为：Models、Prompts、Indexes、Memory、Chains、Agents。</p><h5 id="1-Models"><a href="#1-Models" class="headerlink" title="1. Models"></a>1. Models</h5><p>LangChain 为使用聊天模型提供了一个标准接口。LangChain 目前支持的消息类型有<code>AIMessage</code>、<code>HumanMessage</code>、<code>SystemMessage</code> 和 <code>ChatMessage</code>，其中<code>ChatMessage</code>接受一个任意的角色参数。大多数情况下，您只需要处理 HumanMessage、AIMessage 和 SystemMessage。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入OpenAI的聊天模型，及消息类型</span></span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> (</span><br><span class="line">    AIMessage,</span><br><span class="line">    HumanMessage,</span><br><span class="line">    SystemMessage</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化聊天对象</span></span><br><span class="line">chat = ChatOpenAI(openai_api_key=<span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向聊天模型发问</span></span><br><span class="line">chat([HumanMessage(content=<span class="string">&quot;Translate this sentence from English to French: I love programming.&quot;</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持多个消息作为输入</span></span><br><span class="line">messages = [</span><br><span class="line">    SystemMessage(content=<span class="string">&quot;You are a helpful assistant that translates English to French.&quot;</span>),</span><br><span class="line">    HumanMessage(content=<span class="string">&quot;I love programming.&quot;</span>)</span><br><span class="line">]</span><br><span class="line">chat(messages)</span><br></pre></td></tr></table></figure><p>如果用户问聊天模型同一个问题，对结果进行了缓存，这样就可以减少接口的调用并且也能加快接口返回的速度。提供了两种缓存方案，内存缓存方案和数据库缓存方案.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入聊天模型，SQLiteCache模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;your apikey&#x27;</span></span><br><span class="line"><span class="keyword">import</span> langchain</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.cache <span class="keyword">import</span> SQLiteCache</span><br><span class="line"><span class="comment"># 设置语言模型的缓存数据存储的地址</span></span><br><span class="line">langchain.llm_cache = SQLiteCache(database_path=<span class="string">&quot;.langchain.db&quot;</span>)</span><br><span class="line"><span class="comment"># 加载 llm 模型</span></span><br><span class="line">llm = ChatOpenAI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次向模型提问</span></span><br><span class="line">result = llm.predict(<span class="string">&#x27;tell me a joke&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次向模型提问同样的问题</span></span><br><span class="line">result2 = llm.predict(<span class="string">&#x27;tell me a joke&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br></pre></td></tr></table></figure><h5 id="2-Embeddings"><a href="#2-Embeddings" class="headerlink" title="2. Embeddings"></a>2. Embeddings</h5><p>文本等内容嵌入成多维数组，可以后续进行相似性的计算和检索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings.openai <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;your apikey&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化嵌入模型</span></span><br><span class="line">embeddings = OpenAIEmbeddings()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把文本通过嵌入模型向量化</span></span><br><span class="line">res = embeddings.embed_query(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h5 id="3-LLMs"><a href="#3-LLMs" class="headerlink" title="3. LLMs"></a>3. LLMs</h5><p>LangChain继承了许多大语言模型。</p><h4 id="4-Propmts"><a href="#4-Propmts" class="headerlink" title="4. Propmts"></a>4. Propmts</h4><p><code>LangChain</code> 提供了 <code>PromptTemplates</code>，允许你可以根据用户输入动态地更改提示，当用户需要输入多个类似的 prompt 时，生成一个 prompt 模板是一个很好的解决方案，可以节省用户的时间和精力。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义生成商店的方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_store_names</span>(<span class="params">store_features</span>):</span><br><span class="line">    prompt_template = <span class="string">&quot;我正在开一家新的商店，它的主要特点是&#123;&#125;。请帮我想出10个商店的名字。&quot;</span></span><br><span class="line">    prompt = prompt_template.<span class="built_in">format</span>(store_features)</span><br><span class="line"></span><br><span class="line">    llm = OpenAI()</span><br><span class="line">    response = llm.generate(prompt, max_tokens=<span class="number">10</span>, temperature=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">    store_names = [gen[<span class="number">0</span>].text.strip() <span class="keyword">for</span> gen <span class="keyword">in</span> response.generations]</span><br><span class="line">    <span class="keyword">return</span> store_names</span><br><span class="line"></span><br><span class="line">store_features = <span class="string">&quot;时尚、创意、独特&quot;</span></span><br><span class="line"></span><br><span class="line">store_names = generate_store_names(store_features)</span><br><span class="line"><span class="built_in">print</span>(store_names)</span><br></pre></td></tr></table></figure><p>LangChainHub包含了许多可以通过LangChain直接加载的Prompt Templates。也可以通过学习他们的 Prompt 设计来给我们以启发.</p><h5 id="5-Few-Shot-example"><a href="#5-Few-Shot-example" class="headerlink" title="5. Few-Shot example"></a>5. Few-Shot example</h5><p>使用FewShotPromptTemplate可以更方便地使用少样本学习策略, 其中包含一组示例问题和对应的答案(few-shot examples)与PromptTemplate，它使用few-shot examples格式化PromptTemplate。当examples较多时，可以使用example_selector选择部分样例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;your apikey&#x27;</span></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate, FewShotPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">examples = [</span><br><span class="line">    &#123;<span class="string">&quot;word&quot;</span>: <span class="string">&quot;黑&quot;</span>, <span class="string">&quot;antonym&quot;</span>: <span class="string">&quot;白&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;word&quot;</span>: <span class="string">&quot;伤心&quot;</span>, <span class="string">&quot;antonym&quot;</span>: <span class="string">&quot;开心&quot;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">example_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">单词: &#123;word&#125;</span></span><br><span class="line"><span class="string">反义词: &#123;antonym&#125;\n</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建提示词模版</span></span><br><span class="line">example_prompt = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;word&quot;</span>, <span class="string">&quot;antonym&quot;</span>],</span><br><span class="line">    template=example_template,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用example_selector选择部分样例</span></span><br><span class="line">example_selector = LengthBasedExampleSelector(</span><br><span class="line">    examples=examples,</span><br><span class="line">    example_prompt=example_prompt,</span><br><span class="line">    <span class="comment"># 最大长度</span></span><br><span class="line">    max_length=<span class="number">25</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建小样本提示词模版</span></span><br><span class="line">few_shot_prompt = FewShotPromptTemplate(</span><br><span class="line">    examples=examples,</span><br><span class="line">    example_prompt=example_prompt,</span><br><span class="line">    prefix=<span class="string">&quot;给出每个单词的反义词&quot;</span>,</span><br><span class="line">    suffix=<span class="string">&quot;单词: &#123;input&#125;\n反义词:&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;input&quot;</span>],</span><br><span class="line">    example_separator=<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化小样本提示词</span></span><br><span class="line">prompt_text = few_shot_prompt.<span class="built_in">format</span>(<span class="built_in">input</span>=<span class="string">&quot;粗&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用OpenAI</span></span><br><span class="line">llm = OpenAI(temperature=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(llm(prompt_text))</span><br></pre></td></tr></table></figure><h4 id="indexes"><a href="#indexes" class="headerlink" title="indexes"></a>indexes</h4><p>索引是指对文档进行结构化的方法，以便 LLM 能够更好的与之交互。该组件主要包括：Document Loaders（文档加载器）、Text Splitters（文本拆分器）、VectorStores（向量存储器）以及 Retrievers（检索器）。</p><h5 id="DocumentLoaer"><a href="#DocumentLoaer" class="headerlink" title="DocumentLoaer"></a>DocumentLoaer</h5><p>指定源进行加载数据的。将特定格式的数据，转换为文本。如 CSV、File Directory、HTML。</p><h5 id="TexSplitter"><a href="#TexSplitter" class="headerlink" title="TexSplitter"></a>TexSplitter</h5><p>由于模型对输入的字符长度有限制，我们在碰到很长的文本时，需要把文本分割成多个小的文本片段。LangChain中最基本的分割器CharacterTextSplitter，它按照指定的分隔符（默认“\n\n”）进行分割，并且考虑文本片段的最大长度。</p><p>LangChain支持多个高级文本分割器如下：<br><img src="/image-12.png" alt="alt text"></p><h5 id="VectorStores、Retrievers"><a href="#VectorStores、Retrievers" class="headerlink" title="VectorStores、Retrievers"></a>VectorStores、Retrievers</h5><p>VectorStores存储提取的文本向量，包括 Faiss、Milvus、Pinecone、Chroma 等。<br>Retrievers检索器是一种便于模型查询的存储数据的方式，LangChain 约定检索器组件至少有一个方法 get_relevant_texts，这个方法接收查询字符串，返回一组文档。</p><h4 id="Chains"><a href="#Chains" class="headerlink" title="Chains"></a>Chains</h4><p>LangChain将上述多个组件组合在一起以创建一个单一的、连贯的任务。例如，可以创建一个链，它接受用户输入，使用 PromptTemplate 对其进行格式化，然后将格式化的响应传递给 LLM。另外我们也可以通过将多个链组合在一起，或者将链与其他组件组合来构建更复杂的链。</p><p>构建chain的步骤：</p><blockquote><ol><li>先写一个提问的模版prompt，其中中括号{}表示你要填入的变量名称。比如：”Tell me a joke about {adjective} tomatoes.”</li><li>组建LLMChain示例，指定llm、prompt两个必要参数，比如chain &#x3D; LLMChain(llm&#x3D;llm, prompt&#x3D;promt,verbose&#x3D;True)。</li><li>启动Chain，通过chain.run传递输入的变量，res &#x3D; chain.run(product)。</li></ol></blockquote><h4 id="LLMChain"><a href="#LLMChain" class="headerlink" title="LLMChain"></a>LLMChain</h4><p>LLMChain（是Chains中的一种）接受一个提示模版，将模版与用户输入进行格式化，并返回LLM的响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate, OpenAI, LLMChain</span><br><span class="line"></span><br><span class="line">prompt_template = <span class="string">&quot;What is a good name for a company that makes &#123;product&#125;?&quot;</span></span><br><span class="line"></span><br><span class="line">llm = OpenAI(temperature=<span class="number">0</span>)</span><br><span class="line">llm_chain = LLMChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    prompt=PromptTemplate.from_template(prompt_template)</span><br><span class="line">)</span><br><span class="line">llm_chain(<span class="string">&quot;colorful socks&quot;</span>)</span><br></pre></td></tr></table></figure><p>run方法和call方法的入参可以是字符串，或者字典数据等</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># call方法返回输入和输出键值，return_only_outputs表示只返回输出键值。</span></span><br><span class="line">llm_chain.call(<span class="string">&quot;corny&quot;</span>, return_only_outputs=<span class="literal">True</span>) <span class="comment">#返回结果只输出键值</span></span><br><span class="line"><span class="comment"># 输出结果 </span></span><br><span class="line">&#123;<span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;Why did the tomato turn red? Because it saw the salad dressing!&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># run方法返回的是字符串</span></span><br><span class="line">llm_chain.run(&#123;<span class="string">&quot;adjective&quot;</span>: <span class="string">&quot;corny&quot;</span>&#125;) <span class="comment">#输入一个字典</span></span><br><span class="line"><span class="comment"># 输出结果 </span></span><br><span class="line"><span class="string">&#x27;Why did the tomato turn red? Because it saw the salad dressing!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># apply方法允许输入列表</span></span><br><span class="line">input_list = [</span><br><span class="line">    &#123;<span class="string">&quot;product&quot;</span>: <span class="string">&quot;socks&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;product&quot;</span>: <span class="string">&quot;computer&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;product&quot;</span>: <span class="string">&quot;shoes&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line">llm_chain.apply(input_list)</span><br><span class="line"><span class="comment"># 输出结果 </span></span><br><span class="line">    [&#123;<span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;\n\nSocktastic!&#x27;</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;\n\nTechCore Solutions.&#x27;</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;\n\nFootwear Factory.&#x27;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate方法类似于apply方法，返回的是LLMResult类型的结果。</span></span><br><span class="line">llm_chain.generate(input_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line">    LLMResult(generations=[[Generation(text=<span class="string">&#x27;\n\nSocktastic!&#x27;</span>, generation_info=&#123;<span class="string">&#x27;finish_reason&#x27;</span>: <span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;logprobs&#x27;</span>: <span class="literal">None</span>&#125;)], [Generation(text=<span class="string">&#x27;\n\nTechCore Solutions.&#x27;</span>, generation_info=&#123;<span class="string">&#x27;finish_reason&#x27;</span>: <span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;logprobs&#x27;</span>: <span class="literal">None</span>&#125;)], [Generation(text=<span class="string">&#x27;\n\nFootwear Factory.&#x27;</span>, generation_info=&#123;<span class="string">&#x27;finish_reason&#x27;</span>: <span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;logprobs&#x27;</span>: <span class="literal">None</span>&#125;)]], llm_output=&#123;<span class="string">&#x27;token_usage&#x27;</span>: &#123;<span class="string">&#x27;prompt_tokens&#x27;</span>: <span class="number">36</span>, <span class="string">&#x27;total_tokens&#x27;</span>: <span class="number">55</span>, <span class="string">&#x27;completion_tokens&#x27;</span>: <span class="number">19</span>&#125;, <span class="string">&#x27;model_name&#x27;</span>: <span class="string">&#x27;text-davinci-003&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">llm_chain.predict(product=<span class="string">&quot;colorful socks&quot;</span>) <span class="comment">#入参为指定关键字参数</span></span><br></pre></td></tr></table></figure><h4 id="SimpleSequentialChain"><a href="#SimpleSequentialChain" class="headerlink" title="SimpleSequentialChain"></a>SimpleSequentialChain</h4><p>简单的顺序链，将输入输出链接起来。</p><p><img src="/image-13.png" alt="alt text"><br>将两个LLMChain进行组合成顺序链调用的案例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> SimpleSequentialChain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第一个chain</span></span><br><span class="line">llm = OpenAI(temperature=<span class="number">.7</span>)</span><br><span class="line">template = <span class="string">&quot;&quot;&quot;You are a playwright. Given the title of play, it is your job to write a synopsis for that title.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Title: &#123;title&#125;</span></span><br><span class="line"><span class="string">Playwright: This is a synopsis for the above play:&quot;&quot;&quot;</span></span><br><span class="line">prompt_template = PromptTemplate(input_variables=[<span class="string">&quot;title&quot;</span>], template=template)</span><br><span class="line">synopsis_chain = LLMChain(llm=llm, prompt=prompt_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第二个chain</span></span><br><span class="line"></span><br><span class="line">llm = OpenAI(temperature=<span class="number">.7</span>)</span><br><span class="line">template = <span class="string">&quot;&quot;&quot;You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Play Synopsis:</span></span><br><span class="line"><span class="string">&#123;synopsis&#125;</span></span><br><span class="line"><span class="string">Review from a New York Times play critic of the above play:&quot;&quot;&quot;</span></span><br><span class="line">prompt_template = PromptTemplate(input_variables=[<span class="string">&quot;synopsis&quot;</span>], template=template)</span><br><span class="line">review_chain = LLMChain(llm=llm, prompt=prompt_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过简单顺序链组合两个LLMChain</span></span><br><span class="line">overall_chain = SimpleSequentialChain(chains=[synopsis_chain, review_chain], verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行顺序链</span></span><br><span class="line">review = overall_chain.run(<span class="string">&quot;Tragedy at sunset on the beach&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="TransformChain"><a href="#TransformChain" class="headerlink" title="TransformChain"></a>TransformChain</h4><p>转换链允许我们创建一个自定义的转换函数来处理输入，将处理后的结果用作下一个链的输入。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> TransformChain, LLMChain, SimpleSequentialChain</span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟超长文本</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;../../state_of_the_union.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    state_of_the_union = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义转换方法，入参和出参都是字典，取前三段</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transform_func</span>(<span class="params">inputs: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    text = inputs[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">    shortened_text = <span class="string">&quot;\n\n&quot;</span>.join(text.split(<span class="string">&quot;\n\n&quot;</span>)[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;output_text&quot;</span>: shortened_text&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换链：输入变量：text，输出变量：output_text</span></span><br><span class="line">transform_chain = TransformChain(</span><br><span class="line">    input_variables=[<span class="string">&quot;text&quot;</span>], output_variables=[<span class="string">&quot;output_text&quot;</span>], transform=transform_func</span><br><span class="line">)</span><br><span class="line"><span class="comment"># prompt模板描述</span></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;Summarize this text:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;output_text&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Summary:&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># prompt模板</span></span><br><span class="line">prompt = PromptTemplate(input_variables=[<span class="string">&quot;output_text&quot;</span>], template=template)</span><br><span class="line"><span class="comment"># llm链</span></span><br><span class="line">llm_chain = LLMChain(llm=OpenAI(), prompt=prompt)</span><br><span class="line"><span class="comment"># 使用顺序链</span></span><br><span class="line">sequential_chain = SimpleSequentialChain(chains=[transform_chain, llm_chain])</span><br><span class="line"><span class="comment"># 开始执行</span></span><br><span class="line">sequential_chain.run(state_of_the_union)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#x27; The speaker addresses the nation, noting that while last year they were kept apart due to COVID-19, this year they are together again.</span></span><br><span class="line"><span class="string">    They are reminded that regardless of their political affiliations, they are all Americans.&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="SequentialChain"><a href="#SequentialChain" class="headerlink" title="SequentialChain"></a>SequentialChain</h4><p>SequentialChain允许每个链具有多个输入输出，重要的是当具有多个输入时，要命名输入&#x2F;输出的变量名称。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> SequentialChain</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">######################################</span></span><br><span class="line"><span class="string">### Chain1 给中文产品名称翻译成英文  ###</span></span><br><span class="line"><span class="string">######################################</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># Chain1 语言转换，产生英文产品名</span></span><br><span class="line">prompt1 = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;将以下文本翻译成英文: &#123;product_name&#125;&quot;</span></span><br><span class="line">)</span><br><span class="line">chain1 = LLMChain(</span><br><span class="line">    <span class="comment"># 使用的大模型实例</span></span><br><span class="line">    llm=llm,</span><br><span class="line">    <span class="comment"># prompt模板</span></span><br><span class="line">    prompt=prompt1,</span><br><span class="line">    <span class="comment"># 输出数据变量名</span></span><br><span class="line">    output_key=<span class="string">&quot;english_product_name&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">##################################################</span></span><br><span class="line"><span class="string">### Chain2 根据英文产品名，生成一段英文介绍文本   ###</span></span><br><span class="line"><span class="string">##################################################</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># Chain2 根据英文产品名，生成一段英文介绍文本</span></span><br><span class="line">prompt2 = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;Based on the following product, give an introduction text about 100 words: &#123;english_product_name&#125;&quot;</span></span><br><span class="line">)</span><br><span class="line">chain2 = LLMChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    prompt=prompt2,</span><br><span class="line">    output_key=<span class="string">&quot;english_introduce&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">###########################################</span></span><br><span class="line"><span class="string">### Chain3 产品名的语言判定(中文or英文)   ###</span></span><br><span class="line"><span class="string">###########################################</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># Chain3 找到产品名所属的语言</span></span><br><span class="line">prompt3 = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;下列文本使用的语言是什么?: &#123;product_name&#125;&quot;</span></span><br><span class="line">)</span><br><span class="line">chain3 = LLMChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    prompt=prompt3,</span><br><span class="line">    output_key=<span class="string">&quot;language&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#########################</span></span><br><span class="line"><span class="string">### Chain4 生成概述   ###</span></span><br><span class="line"><span class="string">#########################</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># Chain4 根据Chain2生成的英文介绍，使用产品名称原本的语言生成一段概述</span></span><br><span class="line">prompt4 = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;使用语言类型为: &#123;language&#125; ，为下列文本写一段不多于50字的概述: &#123;english_introduce&#125;&quot;</span></span><br><span class="line">)</span><br><span class="line">chain4 = LLMChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    prompt=prompt4,</span><br><span class="line">    output_key=<span class="string">&quot;summary&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">############################</span></span><br><span class="line"><span class="string">### 组建SequentialChain  ###</span></span><br><span class="line"><span class="string">############################</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 标准版的序列Chain,SequentialChain,其中每个chain都支持多个输入和输出，</span></span><br><span class="line"><span class="comment"># 根据chains中每个独立chain对象，和chains中的顺序，决定参数的传递，获取最终的输出结果</span></span><br><span class="line">overall_chain = SequentialChain(</span><br><span class="line">    chains=[chain1, chain2, chain3, chain4],</span><br><span class="line">    input_variables=[<span class="string">&quot;product_name&quot;</span>],</span><br><span class="line">    output_variables=[<span class="string">&quot;english_product_name&quot;</span>, <span class="string">&quot;english_introduce&quot;</span>, <span class="string">&quot;language&quot;</span>, <span class="string">&quot;summary&quot;</span>],</span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">product_name = <span class="string">&quot;重庆小面&quot;</span></span><br><span class="line">res = overall_chain(product_name)</span><br></pre></td></tr></table></figure><p>创建步骤简单而言：</p><ol><li>n件事，先写n个LLMChain（提问的模版prompt + chain）</li><li>组建SequentialChain示例，指定chains、input_variables、output_variables三个必要参数</li></ol><ul><li>chains：n个chain，list格式</li><li>input_variables：输入变量，SequentialChain的最初输入</li><li>output_variables：所有的输出变量，SequentialChain的中间输出</li></ul><ol start="3"><li><p>启动Chain，通过overall_chain传递输入的变量product_name</p></li><li><p>输出结果，结果由所有参数构成，字典dict格式。（这种输出方式，有助于代码工程化时的正确取值，dddd）</p></li></ol><h4 id="LLMRouterChain"><a href="#LLMRouterChain" class="headerlink" title="LLMRouterChain"></a>LLMRouterChain</h4><p>LLMRouterChain 是根据提示词的不同而选择不同的Chain进行执行，实现分支判断的作用。</p><p><img src="/image-14.png" alt="alt text"></p><p><strong>构建流程：</strong><br>1.【Step1】初始化语言模型（”qwen:7b”)<br>2.【Step2】构建提示信息（json格式），包括：key、description 和 template</p><ul><li>【Step2.1】构建两个场景的模板</li><li>【Step2.2】构建提示信息</li></ul><p>3.【Step3】构建目标链chain_map（json格式），以提示信息prompt_infos中的key为key，以Chain为value<br>4.【Step4】构建路由链router_chain<br>5.【Step5】构建默认链 default_chain<br>6.【Step6】构建多提示链 MultiPromptChain</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.llm <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.chains.router.llm_router <span class="keyword">import</span> LLMRouterChain, RouterOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain.chains.router.multi_prompt_prompt <span class="keyword">import</span> MULTI_PROMPT_ROUTER_TEMPLATE <span class="keyword">as</span> RounterTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment">## 【Step1】初始化语言模型</span></span><br><span class="line"><span class="comment"># from langchain.llms import OpenAI</span></span><br><span class="line"><span class="comment"># llm = OpenAI()</span></span><br><span class="line"><span class="comment"># llm = AzureChatOpenAI(deployment_name=&quot;GPT-4&quot;, temperature=0)</span></span><br><span class="line"></span><br><span class="line">ollama_llm = Ollama(model=<span class="string">&quot;qwen:7b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 【Step2】构建提示信息（json格式），包括：key、description 和 template</span></span><br><span class="line"><span class="comment"># 【Step2.1】构建两个场景的模板</span></span><br><span class="line">flower_care_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你是一个经验丰富的园丁，擅长解答关于养花育花的问题。</span></span><br><span class="line"><span class="string">下面是需要你来回答的问题:</span></span><br><span class="line"><span class="string">&#123;input&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">flower_deco_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你是一位网红插花大师，擅长解答关于鲜花装饰的问题。</span></span><br><span class="line"><span class="string">下面是需要你来回答的问题:</span></span><br><span class="line"><span class="string">&#123;input&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【Step2.2】构建提示信息</span></span><br><span class="line">prompt_infos = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key&quot;</span>: <span class="string">&quot;flower_care&quot;</span>,</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;适合回答关于鲜花护理的问题&quot;</span>,</span><br><span class="line">        <span class="string">&quot;template&quot;</span>: flower_care_template,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key&quot;</span>: <span class="string">&quot;flower_decoration&quot;</span>,</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;适合回答关于鲜花装饰的问题&quot;</span>,</span><br><span class="line">        <span class="string">&quot;template&quot;</span>: flower_deco_template,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 【Step3】构建目标链chain_map（json格式），以提示信息prompt_infos中的key为key，以Chain为value</span></span><br><span class="line">chain_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> info <span class="keyword">in</span> prompt_infos:</span><br><span class="line">    prompt = PromptTemplate(</span><br><span class="line">        template=info[<span class="string">&#x27;template&#x27;</span>],</span><br><span class="line">        input_variables=[<span class="string">&quot;input&quot;</span>] <span class="comment">#指定输入变量input</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;目标提示:\n&quot;</span>, prompt)</span><br><span class="line">    </span><br><span class="line">    chain = LLMChain(</span><br><span class="line">        llm=ollama_llm,</span><br><span class="line">        prompt=prompt,</span><br><span class="line">        verbose=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    chain_map[info[<span class="string">&quot;key&quot;</span>]] = chain</span><br><span class="line"></span><br><span class="line"><span class="comment">## 【Step4】构建路由链router_chain</span></span><br><span class="line">destinations = [<span class="string">f&quot;<span class="subst">&#123;p[<span class="string">&#x27;key&#x27;</span>]&#125;</span>: <span class="subst">&#123;p[<span class="string">&#x27;description&#x27;</span>]&#125;</span>&quot;</span> <span class="keyword">for</span> p <span class="keyword">in</span> prompt_infos]</span><br><span class="line">router_template = RounterTemplate.<span class="built_in">format</span>(destinations=<span class="string">&quot;\n&quot;</span>.join(destinations))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;路由模板:\n&quot;</span>, router_template)</span><br><span class="line"></span><br><span class="line">router_prompt = PromptTemplate(</span><br><span class="line">    template=router_template,</span><br><span class="line">    input_variables=[<span class="string">&quot;input&quot;</span>],</span><br><span class="line">    output_parser=RouterOutputParser(), <span class="comment">#解析模型输出确定最佳目的地</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;路由提示:\n&quot;</span>, router_prompt)</span><br><span class="line"></span><br><span class="line">router_chain = LLMRouterChain.from_llm(</span><br><span class="line">    ollama_llm,</span><br><span class="line">    router_prompt,</span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 【Step5】构建默认链 default_chain </span></span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> ConversationChain</span><br><span class="line">default_chain = ConversationChain(</span><br><span class="line">    llm=ollama_llm,</span><br><span class="line">    output_key=<span class="string">&quot;text&quot;</span>,</span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 【Step6】构建多提示链 MultiPromptChain</span></span><br><span class="line"><span class="keyword">from</span> langchain.chains.router <span class="keyword">import</span> MultiPromptChain</span><br><span class="line"></span><br><span class="line">chain = MultiPromptChain(</span><br><span class="line">    router_chain=router_chain,</span><br><span class="line">    destination_chains=chain_map,</span><br><span class="line">    default_chain=default_chain,</span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试1</span></span><br><span class="line"><span class="built_in">print</span>(chain.run(<span class="string">&quot;如何为玫瑰浇水？&quot;</span>))</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/sinat_29950703/article/details/136216665">RouterChain相关应用，RouterChain可以将你的不同问题转发给不同专家链进行回答</a></p><h4 id="Memeory"><a href="#Memeory" class="headerlink" title="Memeory"></a>Memeory</h4><p>OpenAI提供的聊天接口 api，本身是不具备“记忆的”能力。如果想要使聊天具有记忆功能，则需要我们自行维护聊天记录，即每次把聊天记录发给语言模型。具体过程如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一次发送</span></span><br><span class="line">openai.ChatCompletion.create(</span><br><span class="line">  model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">  messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a helpful assistant.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Hello&quot;</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="comment">#第二次发送</span></span><br><span class="line"></span><br><span class="line">openai.ChatCompletion.create(</span><br><span class="line">  model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">  messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a helpful assistant.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Hello&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Hello, how can I help you?&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;who is more stylish Pikachu or Neo&quot;</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>只需要保存最近几次的聊天记录，LangChain提供Memory组件保存聊天记忆。</p><h5 id="使用Memory组件"><a href="#使用Memory组件" class="headerlink" title="使用Memory组件"></a>使用Memory组件</h5><h6 id="1-ChatMessageHistory"><a href="#1-ChatMessageHistory" class="headerlink" title="1. ChatMessageHistory"></a>1. ChatMessageHistory</h6><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ChatMessageHistory</span><br><span class="line"><span class="keyword">from</span> langchain_community.llms <span class="keyword">import</span> Tongyi</span><br><span class="line">llm = Tongyi()</span><br><span class="line"></span><br><span class="line">history = ChatMessageHistory()</span><br><span class="line">history.add_user_message(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">history.add_ai_message(<span class="string">&quot;你好?&quot;</span>)</span><br><span class="line">history.add_user_message(<span class="string">&quot;请问丹麦的首都是哪里?&quot;</span>)</span><br><span class="line">history.add_ai_message(<span class="string">&quot;哥本哈根&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(history.messages)</span><br><span class="line"></span><br><span class="line">ret = llm.invoke(history.messages)</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure><h5 id="2-ConversationBufferMemory"><a href="#2-ConversationBufferMemory" class="headerlink" title="2. ConversationBufferMemory"></a>2. ConversationBufferMemory</h5><p><code>ConversationBufferMemory</code>是<code>Langchain</code>框架中用于存储对话历史的一个内存组件。它类似于一个缓冲区，将对话中的所有消息（包括用户输入和AI响应）按照顺序存储起来，<strong>这样向LLM发送的消息就会带上最近几次的聊天记录了</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过 ConversationBufferMemory（缓冲记忆）可以实现最简单的记忆机制。</span></span><br><span class="line"><span class="keyword">from</span> langchain.chains.conversation.base <span class="keyword">import</span> ConversationChain</span><br><span class="line"><span class="keyword">from</span> langchain_community.llms <span class="keyword">import</span> Tongyi</span><br><span class="line"></span><br><span class="line">llm = Tongyi()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.chains.conversation.memory <span class="keyword">import</span> ConversationBufferMemory</span><br><span class="line"></span><br><span class="line">conversation = ConversationChain(llm=llm,memory=ConversationBufferMemory())</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一天的对话</span></span><br><span class="line"><span class="comment">#回合1</span></span><br><span class="line">conversation.invoke(<span class="string">&quot;我姐姐明天要过生日，我需要一束生日花束。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一次对话后的记忆:&quot;</span>, conversation.memory.buffer,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回合2</span></span><br><span class="line">conversation.invoke(<span class="string">&quot;她喜欢粉色玫瑰，颜色是粉色的。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第二次对话后的记忆:&quot;</span>, conversation.memory.buffer,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回合3 （第二天的对话）</span></span><br><span class="line">conversation.invoke(<span class="string">&quot;我又来了，还记得我昨天为什么要来买花吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n第三次对话后时提示:\n&quot;</span>,conversation.prompt.template)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n第三次对话后的记忆:\n&quot;</span>, conversation.memory.buffer,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-ConversationBufferWindowMemory"><a href="#3-ConversationBufferWindowMemory" class="headerlink" title="3. ConversationBufferWindowMemory"></a>3. ConversationBufferWindowMemory</h5><p><code>ConversationBufferWindowMemory</code>基于滑动窗口的概念，只保留对话历史中的最近几轮交互。这种机制类似于人类的短期记忆，能够高效地管理对话上下文，同时减少内存占用。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现一个最近的对话窗口，超过窗口条数的对话将被删除</span></span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span>  ConversationBufferWindowMemory</span><br><span class="line"></span><br><span class="line">memory = ConversationBufferWindowMemory(k=<span class="number">5</span>) <span class="comment">#保存最近五次的对话窗口</span></span><br><span class="line"></span><br><span class="line">memory.save_context(&#123;<span class="string">&quot;input&quot;</span>:<span class="string">&quot;你好，我是人类!&quot;</span>&#125;,&#123;<span class="string">&quot;output&quot;</span>:<span class="string">&quot;你好，我是AI，有什么可以帮助你的吗？&quot;</span>&#125;)</span><br><span class="line">memory.save_context(&#123;<span class="string">&quot;input&quot;</span>:<span class="string">&quot;我想吃鸭肉&quot;</span>&#125;,&#123;<span class="string">&quot;output&quot;</span>:<span class="string">&quot;好的，我帮你找找鸭肉的做法&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(memory.buffer)</span><br></pre></td></tr></table></figure><h5 id="4-ConversationEntityMemory"><a href="#4-ConversationEntityMemory" class="headerlink" title="4. ConversationEntityMemory"></a>4. ConversationEntityMemory</h5><p> Langchain的Memory组件中的ConversationEntityMemory是一种特殊的记忆组件，它专注于跟踪和存储对话中提及的实体信息。 它通过识别对话中的实体（如人名、地名、产品名等），并将这些实体及其相关信息存储在内存中。</p><h5 id="5-ConversationKGMemory"><a href="#5-ConversationKGMemory" class="headerlink" title="5. ConversationKGMemory"></a>5. ConversationKGMemory</h5><p><code>ConversationKGMemory</code>是<code>Langchain</code>中的一个内存组件，它将对话历史中的关键信息（如实体、概念等）映射到知识图谱中，建立对话上下文与知识库之间的联系。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用知识图谱构建记忆</span></span><br><span class="line"><span class="comment"># from langchain.memory import ConversationKGMemory</span></span><br><span class="line"><span class="keyword">from</span> langchain_community.memory.kg <span class="keyword">import</span> ConversationKGMemory</span><br><span class="line"><span class="keyword">from</span> langchain_community.llms <span class="keyword">import</span> Tongyi</span><br><span class="line">llm = Tongyi()</span><br><span class="line"></span><br><span class="line">memory = ConversationKGMemory(llm=llm)</span><br><span class="line">memory.save_context(&#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;say hi to dahuang&quot;</span>&#125;, &#123;<span class="string">&quot;output&quot;</span>: <span class="string">&quot;who is dahuang&quot;</span>&#125;)</span><br><span class="line">memory.save_context(&#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;dahuang is a dog name&quot;</span>&#125;, &#123;<span class="string">&quot;output&quot;</span>: <span class="string">&quot;okay&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(memory.load_memory_variables(&#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;who is xiaohei&quot;</span>&#125;))</span><br><span class="line"><span class="built_in">print</span>(memory.load_memory_variables(&#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;who is dahuang&quot;</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(memory.get_knowledge_triplets(<span class="string">&quot;her favorite color is red&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(memory.get_current_entities(<span class="string">&quot;what&#x27;s Sams favorite color?&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(memory.get_current_entities(<span class="string">&quot;穿着蓝色衣服、手里拿着冰糖葫芦的小明与小花正在去爬山&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(memory.get_current_entities(<span class="string">&quot;大壮的职业一个消防员&quot;</span>))</span><br></pre></td></tr></table></figure><h5 id="6-ConversationSummaryMemory"><a href="#6-ConversationSummaryMemory" class="headerlink" title="6. ConversationSummaryMemory"></a>6. ConversationSummaryMemory</h5><p>ConversationSummaryMemory通过对整个对话的内容进行总结，生成一个简洁的对话摘要，并记住这个摘要。</p><h4 id="在链上使用Memory"><a href="#在链上使用Memory" class="headerlink" title="在链上使用Memory"></a>在链上使用Memory</h4><h5 id="1-LLMChain上使用Memory"><a href="#1-LLMChain上使用Memory" class="headerlink" title="1. LLMChain上使用Memory"></a>1. LLMChain上使用Memory</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.llm <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ConversationBufferMemory</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_community.llms <span class="keyword">import</span> Tongyi</span><br><span class="line">llm = Tongyi()</span><br><span class="line"></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;你是一个机器人助理。</span></span><br><span class="line"><span class="string">&#123;chat_history&#125;</span></span><br><span class="line"><span class="string">user:&#123;human_input&#125;</span></span><br><span class="line"><span class="string">AI:&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prompt= PromptTemplate(</span><br><span class="line">    template=template,</span><br><span class="line">    input_variables=[<span class="string">&quot;chat_history&quot;</span>, <span class="string">&quot;human_input&quot;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">memory = ConversationBufferMemory(</span><br><span class="line">    memory_key=<span class="string">&quot;chat_history&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chain = LLMChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=memory,</span><br><span class="line">    prompt=prompt,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chain.invoke(<span class="string">&quot;中国的首都是哪里？&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chain.invoke(<span class="string">&quot;推荐一个旅游景点&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chain.invoke(<span class="string">&quot;怎么去？&quot;</span>))</span><br></pre></td></tr></table></figure><h5 id="2-ConversationChain上使用Memory"><a href="#2-ConversationChain上使用Memory" class="headerlink" title="2. ConversationChain上使用Memory"></a>2. ConversationChain上使用Memory</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.conversation.base <span class="keyword">import</span> ConversationChain</span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ConversationBufferMemory</span><br><span class="line"><span class="keyword">from</span> langchain_community.llms <span class="keyword">import</span> Tongyi</span><br><span class="line">llm = Tongyi()</span><br><span class="line"></span><br><span class="line">memory = ConversationBufferMemory(</span><br><span class="line">    memory_key=<span class="string">&quot;history&quot;</span>,</span><br><span class="line">    return_messages=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">chain = ConversationChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=memory</span><br><span class="line">)</span><br><span class="line">tp = &#123;</span><br><span class="line">    <span class="string">&quot;input&quot;</span>: <span class="string">&quot;给我讲一个笑话&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain.invoke(<span class="string">&quot;给我讲一个笑话&quot;</span>)</span><br><span class="line">chain.invoke(<span class="string">&quot;这个不好笑&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(memory.buffer)</span><br></pre></td></tr></table></figure><h5 id="3-同一个链合并使用多个memory"><a href="#3-同一个链合并使用多个memory" class="headerlink" title="3. 同一个链合并使用多个memory"></a>3. 同一个链合并使用多个memory</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from langchain.Langchain_Chains import ConversationChain</span></span><br><span class="line"><span class="keyword">from</span> langchain.chains.conversation.base <span class="keyword">import</span> ConversationChain</span><br><span class="line"><span class="comment"># from langchain.llms import OpenAI</span></span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> (</span><br><span class="line">    ConversationBufferMemory,</span><br><span class="line">    ConversationSummaryMemory,</span><br><span class="line">    CombinedMemory</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_community.llms <span class="keyword">import</span> Tongyi</span><br><span class="line">llm = Tongyi()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用CoversationSummaryMemory对对话进行总结</span></span><br><span class="line">summay = ConversationSummaryMemory(</span><br><span class="line">    llm=llm,</span><br><span class="line">    input_key=<span class="string">&quot;input&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">#使用ConversationBufferMemory对对话进行缓存</span></span><br><span class="line">cov_memory = ConversationBufferMemory(</span><br><span class="line">    memory_key=<span class="string">&quot;history_now&quot;</span>,</span><br><span class="line">    input_key=<span class="string">&quot;input&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并使用多个memory</span></span><br><span class="line">memory = CombinedMemory(</span><br><span class="line">    memories=[summay, cov_memory],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">TEMPLATE = <span class="string">&quot;&quot;&quot;下面是一段AI与人类的对话，AI会针对人类问题，提供尽可能详细的回答，如果AI不知道答案，会直接回复&#x27;人类老爷，我真的不知道&#x27;.</span></span><br><span class="line"><span class="string">之前的对话摘要:</span></span><br><span class="line"><span class="string">&#123;history&#125;</span></span><br><span class="line"><span class="string">当前对话:</span></span><br><span class="line"><span class="string">&#123;history_now&#125;</span></span><br><span class="line"><span class="string">Human:&#123;input&#125;</span></span><br><span class="line"><span class="string">AI：&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    template=TEMPLATE,</span><br><span class="line">    input_variables=[<span class="string">&quot;history&quot;</span>, <span class="string">&quot;history_now&quot;</span>, <span class="string">&quot;input&quot;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chain = ConversationChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=memory,</span><br><span class="line">    prompt=prompt</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chain.run(<span class="string">&quot;2024年NBA冠军是谁&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(chain.run(<span class="string">&quot;介绍一下python语言&quot;</span>))</span><br></pre></td></tr></table></figure><h5 id="4-构建问答对话链"><a href="#4-构建问答对话链" class="headerlink" title="4. 构建问答对话链"></a>4. 构建问答对话链</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构建问答对话链</span></span><br><span class="line"><span class="keyword">from</span> langchain.chains.question_answering <span class="keyword">import</span> load_qa_chain</span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ConversationBufferMemory</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_community.llms <span class="keyword">import</span> Tongyi</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line">llm = Tongyi()</span><br><span class="line"></span><br><span class="line">docs = [Document(page_content=<span class="string">&#x27;这是一些无用的干扰项文本\n，这是一些无用的干扰项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本\n项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本\n项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本\n项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本\n项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本项文本，这是一些无用的干扰项文本\n在2025年NBA总决赛的最后一场比赛中，哈哈队在主场以94-89击败热火，以总比分4-1成功夺得NBA总冠军。这是球队历史上第一次获得总冠军，也是球队自1976年进入NBA以来的最佳成绩。哈哈队的成功主要归功于他们的领袖球员HAHA的出色表现。\n在总决赛的五场比赛中，HAHA展现出了惊人的统治力。他场均贡献30.2分、14个篮板和7.2次助攻，成为球队得分、篮板和助攻的核心。HAHA在进攻端展现出了全面的技术，他的得分能力和篮板能力让热火队无可奈何。同时，他还展现出了出色的组织能力，为球队创造了很多得分机会。\n在总决赛的最后一场比赛中，HAHA更是发挥出色。他在关键时刻承担责任，不仅在进攻端贡献了关键得分，还在防守端起到了重要作用。他的领导能力和稳定性为球队赢得了决胜的胜利。\nHAHA荣获总决赛最有价值球员（MVP）毫无悬念。他在总决赛中的出色表现让他成为了不可或缺的球队核心，也让他获得了职业生涯中的首个总冠军。这一荣誉不仅是对他个人努力的认可，也是对他带领球队取得成功的肯定。\n随着HAHA的崛起，哈哈队在过去几个赛季中逐渐崭露头角。他的全面发展和领导能力使他成为了球队的核心和灵魂人物。通过这次总决赛的胜利，孙健不仅实现了自己的篮球梦想，也为球队带来了无比的荣耀。\nHAHA带领哈哈队赢得2025年NBA总冠军，并凭借出色的表现获得总决赛最有价值球员（MVP）的荣誉。他在总决赛期间的统治力和全面能力使他成为球队的核心，同时也展现了他的领导才能。这次胜利不仅是HAHA个人职业生涯的里程碑，也是哈哈队迈向更高荣耀的关键一步。随着HAHA的领导，哈哈队有望在未来继续取得更多的成功。&#x27;</span>),]</span><br><span class="line"></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;下面是一段AI与人类的对话，AI会针对人类问题，提供尽可能详细的回答，如果AI不知道答案，会直接回复&#x27;人类老爷，我真的不知道&#x27;，参考一下相关文档以及历史对话信息，AI会据此组织最终回答内容.</span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string">&#123;chat_history&#125;</span></span><br><span class="line"><span class="string">Human:&#123;human_input&#125;</span></span><br><span class="line"><span class="string">AI:&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    template=template,</span><br><span class="line">    input_variables=[<span class="string">&quot;context&quot;</span>, <span class="string">&quot;chat_history&quot;</span>, <span class="string">&quot;human_input&quot;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用ConversationBufferMemory对对话进行缓存</span></span><br><span class="line">memory = ConversationBufferMemory(</span><br><span class="line">    memory_key=<span class="string">&quot;chat_history&quot;</span>,</span><br><span class="line">    input_key=<span class="string">&quot;human_input&quot;</span>,</span><br><span class="line">    return_messages=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载对话链</span></span><br><span class="line">chain = load_qa_chain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    memory=memory,</span><br><span class="line">    prompt=prompt,</span><br><span class="line">    chain_type=<span class="string">&quot;stuff&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chain.run(&quot;2024年NBA冠军是谁&quot;)</span></span><br><span class="line"><span class="comment"># chain(&#123;&quot;input_documents&quot;:docs,&quot;human_input&quot;:&quot;公司的营销策略是什么？&quot;&#125;)</span></span><br><span class="line"><span class="built_in">print</span>(chain(&#123;<span class="string">&quot;input_documents&quot;</span>: docs, <span class="string">&quot;human_input&quot;</span>: <span class="string">&quot;2025年NBA冠军是谁？&quot;</span>&#125;))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后端日志-week3</title>
      <link href="/2024/08/19/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week03/"/>
      <url>/2024/08/19/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week03/</url>
      
        <content type="html"><![CDATA[<h2 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h2><blockquote><p>tips : mysql-connector-java的包版本用高级的就行。<br>telnet ip port 可以测试服务器连通性和端口状态</p></blockquote><h3 id="详解Nginx"><a href="#详解Nginx" class="headerlink" title="详解Nginx"></a>详解Nginx</h3><p>Nginx以其高并发连接处理能力，和低资源消耗而闻名，有报告表明能支持高达50,000个并发连接数。</p><h4 id="Nginx特点"><a href="#Nginx特点" class="headerlink" title="Nginx特点"></a>Nginx特点</h4><ul><li>高并发处理能力：采用异步、事件驱动架构，能够高效处理大量并发连接；</li><li>低内存消耗：与其他Web服务器相比，Nginx的内存消耗非常低。</li><li>高可靠性和稳定性：即使在高负载情况下，Nginx也能保持稳定运行；</li><li>跨平台：支持多种操作系统，包括：Linux、Windows等上。</li></ul><h4 id="Nginx功能"><a href="#Nginx功能" class="headerlink" title="Nginx功能"></a>Nginx功能</h4><h5 id="1-反向代理"><a href="#1-反向代理" class="headerlink" title="1. 反向代理"></a>1. 反向代理</h5><p>Nginx反向代理，接收客户端请求，然后将这些请求转发给后端服务器处理，并将后端服务器的响应返回给客户端。反向代理可以解决跨域问题、Web缓存等问题，还可以隐藏后端服务器的地址。</p><h5 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2. 负载均衡"></a>2. 负载均衡</h5><p>Nginx负载均衡功能强大，可以通过“多种策略”，将客户端请求分发到多个后端服务器，从而提高应用的可用性、和响应速度。</p><ul><li>轮询，轮询是默认的负载均衡策略，NGINX按顺序将请求依次分配给每个后端服务器。</li><li>权重：通过指定每个服务器的权重，可以控制请求的分配比例，权重越高的服务器分配到的请求越多。</li><li>最少连接：将请求分配给当前活动连接数最少的服务器，适用于请求处理时间长且差异大的场景。</li></ul><h5 id="3-动静分离"><a href="#3-动静分离" class="headerlink" title="3. 动静分离"></a>3. 动静分离</h5><p>动静分离，它的主要目标是将动态内容（如Java、PHP、Python…等生成的页面），和静态内容（如HTML、CSS、JavaScript、图片等）分开处理，以提高网站的性能和可维护性。</p><h5 id="4-静态文件服务"><a href="#4-静态文件服务" class="headerlink" title="4. 静态文件服务"></a>4. 静态文件服务</h5><p>用作静态文件的快速传输，它能够有效地处理大量的并发连接和高流量请求，是处理静态内容很好的选择。</p><h4 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h4><p>Nginx的配置文件：通常位于<code>/etc/nginx/nginx.conf</code>，主要分为全局块、events块、和http块三个部分。</p><h5 id="1-全局块"><a href="#1-全局块" class="headerlink" title="1. 全局块"></a>1. 全局块</h5><p>全局块包含：全局指令，对整个NGINX服务器的行为进行全局设置，它通常位于配置文件的开头。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log;</span><br></pre></td></tr></table></figure><ul><li>worker_processes: 指定NGINX worker进程的数量，通常使用 auto 自动设置。</li><li>error_log: 指定NGINX的错误日志路径。</li></ul><h5 id="2-Events块"><a href="#2-Events块" class="headerlink" title="2. Events块"></a>2. Events块</h5><p>Events 块用于配置与NGINX工作进程相关的参数，主要控制NGINX如何处理连接。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>worker_connections: 每个worker进程能够同时处理的最大连接数；</li><li>multi_accept: 是否开启多个accept_mutex互斥锁；</li><li>use: 指定使用的事件驱动模块，如 epoll, kqueue, eventport.</li></ul><h5 id="3-http块（核心配置，代表nginx服务器本身的配置）"><a href="#3-http块（核心配置，代表nginx服务器本身的配置）" class="headerlink" title="3. http块（核心配置，代表nginx服务器本身的配置）"></a>3. http块（核心配置，代表nginx服务器本身的配置）</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>      <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>     <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/sites-enabled/*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>default_type: 定义默认的MIME类型（比如Application&#x2F;JSON），当找不到正确的MIME类型时使用；</li><li>log_format: 定义日志的格式；</li><li>access_log: 定义访问日志的路径和格式；</li><li>include: 引入其他配置文件；</li><li>gzip: 配置gzip压缩；</li><li>location: 配置请求的处理规则</li></ul><h5 id="location匹配规则"><a href="#location匹配规则" class="headerlink" title="location匹配规则"></a>location匹配规则</h5><blockquote><ol><li>location &#x3D; xxx  &#x2F;&#x2F;精确匹配，不允许任何额外字符的请求，如&#x2F;xxx和&#x2F;xxx&#x2F;都会返回404（页面未找到）。</li><li>location ^~ xxx  &#x2F;&#x2F;前缀匹配，会忽略请求中的URI剩余部分，如&#x2F;xxx&#x2F;abc与&#x2F;xxx&#x2F;abc&#x2F;def都会匹配到。</li><li>location ~ xxx  &#x2F;&#x2F;正则表达式匹配（区分大小写），如果请求的URL匹配了正则表达式，那么就使用该location配置；</li><li>location ~* xxx  &#x2F;&#x2F;正则表达式匹配（不区分大小写）</li><li>location &#x2F;xxx  &#x2F;&#x2F;普通匹配，任意请求路径中只要包含&#x2F;xxx即匹配</li><li>location &#x2F;  &#x2F;&#x2F;匹配所有的请求</li></ol></blockquote><h5 id="配置例子"><a href="#配置例子" class="headerlink" title="配置例子"></a>配置例子</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//<span class="section">upstream</span> 代表你的后端服务器地址</span><br><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.2:80</span>; //直接写IP地址与端口</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend3.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123; // /代表所有路径都匹配</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend; //代理到后端服务或者本地项目常见的（<span class="attribute">proxy_pass</span> http://localhost:8080;）</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>; //这设置了代理请求的Host头部为原始请求的Host头部。这意味着后端服务器将看到与客户端请求相同的Host头部。</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>; //这设置了代理请求的X-Real-IP头部为客户端的IP地址（$remote_addr）。这允许后端服务器知道原始请求者的真实IP地址，即使请求是通过Nginx代理的。</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /images/ &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx; //设定请求的根目录，nginx会在这个指定的目录下寻找资源，一般而言，用来指定静态资源所在的文件路径</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h3><p>FastJson支持Java对象到JSON的序列化和JSON到Java对象的反序列化，同时支持对JSON字符串的高效解析。</p><h4 id="序列化和反序列化Java对象、解析JSON字符串"><a href="#序列化和反序列化Java对象、解析JSON字符串" class="headerlink" title="序列化和反序列化Java对象、解析JSON字符串"></a>序列化和反序列化Java对象、解析JSON字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(user); <span class="comment">//Java对象序列化为JSON字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(jsonStr, User.class);<span class="comment">//JSON字符串反序列化为Java对象，可以说parse类的都是json字符串转java对象的功能</span></span><br><span class="line"></span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(jsonStr); <span class="comment">//将json字符串解析成对象</span></span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> jsonObject.getIntValue(<span class="string">&quot;id&quot;</span>); <span class="comment">//解析JSON</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;name&quot;</span>); </span><br><span class="line"></span><br><span class="line">List&lt;OrderVo&gt; list = JSON.parseArray(data, OrderVo.class); <span class="comment">//将json字符串(包含多个json数据的数组)转换实体类数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="day05"><a href="#day05" class="headerlink" title="day05"></a>day05</h2><h3 id="Mybatis和Mybatis-plus的混合使用"><a href="#Mybatis和Mybatis-plus的混合使用" class="headerlink" title="Mybatis和Mybatis-plus的混合使用"></a>Mybatis和Mybatis-plus的混合使用</h3><blockquote><p>tips: 其实直接导下面两个包就行，配置写mybatis-plus的配置，mybatis-spring-boot-starter和mybatis-plus-spring-boot-starter。</p></blockquote><h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp</span><br><span class="line">netstat -tnlp | grep :22 #查看指定端口运行状态</span><br><span class="line">lsof -i:8600  #-i:端口号</span><br><span class="line">ps -ef|grep nginx #查看与nginx相关的文件</span><br><span class="line">find / -name xxx #在整个linux系统查找xxx文件</span><br><span class="line">touch a.txt #创建文件</span><br><span class="line">less/cat/more/tail/head a.txt #查看文件内容，head和tail查看文件头几行和尾几行，head</span><br><span class="line">cp file1 file2 #复制文件</span><br><span class="line">mv file1 file2 #重命名文件</span><br><span class="line">rm -rf file1 #删除文件</span><br><span class="line">chmod 777 file1 #更改文件权限,第一位数字所有者权限，第二位组权限，第三位其他用户权限 7读写，5读和执行</span><br></pre></td></tr></table></figure><h3 id="可以直接vim-jar包改配置文件"><a href="#可以直接vim-jar包改配置文件" class="headerlink" title="可以直接vim jar包改配置文件"></a>可以直接vim jar包改配置文件</h3><h4 id="vim三大模式"><a href="#vim三大模式" class="headerlink" title="vim三大模式"></a>vim三大模式</h4><p><img src="/image-10.png" alt="alt text"></p><h4 id="vim相关快捷操作"><a href="#vim相关快捷操作" class="headerlink" title="vim相关快捷操作"></a>vim相关快捷操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行模式</span></span><br><span class="line">/xxx # 查找字符xxx</span><br><span class="line">u # 撤销</span><br><span class="line">Ctrl + r # 反撤销</span><br><span class="line">. # 重复上一个动作</span><br><span class="line">gg # 到第一行</span><br><span class="line">G #到最后一行 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>工作日志</title>
      <link href="/2024/08/14/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%9701/"/>
      <url>/2024/08/14/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%9701/</url>
      
        <content type="html"><![CDATA[<h2 id="6-30-501-AI中心会议"><a href="#6-30-501-AI中心会议" class="headerlink" title="6:30 501 AI中心会议"></a>6:30 501 AI中心会议</h2><h3 id="主题：抓紧人工智能，促发新质生产力"><a href="#主题：抓紧人工智能，促发新质生产力" class="headerlink" title="主题：抓紧人工智能，促发新质生产力"></a>主题：抓紧人工智能，促发新质生产力</h3><h4 id="大模型相关"><a href="#大模型相关" class="headerlink" title="大模型相关"></a>大模型相关</h4><ul><li>星辰大模型相关：Agent+生态，赶超3.5，追齐4.0</li></ul><p>以星辰大模型为基模：12个行业大模型（政务，教育，旅游导览等）</p><ul><li><p>星辰基础模型：满足红色价值观，比如在钓鱼岛问题的立场坚定。</p></li><li><p>星辰·慧笔：写作助手，支持文本风格定义。</p></li><li><p>星辰·语音大模型：多方言语音识别（293种方言），语音生成真人化。</p></li><li><p>星辰·慧记：生成会议纪要，区别发言人，进行总结，拾音器收集会议语音。</p></li><li><p>星辰·多模态大模型：文生图，文字图片风格对齐。单图生成解说视频。</p></li><li><p>星辰基层治理大模型：融入民法典，法律知识，进行法律调解。</p></li><li><p>星辰教学大模型：帮助老师进行阅卷，生成教案等。</p></li></ul><h4 id="小模型相关"><a href="#小模型相关" class="headerlink" title="小模型相关"></a>小模型相关</h4><p>CV模型相关，人脸识别，小目标检测，行人行为检测，卫生检测等。</p><h4 id="AI硬件"><a href="#AI硬件" class="headerlink" title="AI硬件"></a>AI硬件</h4><p>视联智盒，大模型一体机，TeleSearch一体机。</p><p><strong>应用：</strong><br>酒店陌生人识别系统等。</p><p><strong>扶摇平台为事业部提供什么：</strong></p><p>调用CV模型，算力方面目前不能提供。</p><h2 id="智能客服会议"><a href="#智能客服会议" class="headerlink" title="智能客服会议"></a>智能客服会议</h2><p>更多问法，人工标记问题。<br>保存提问记录。<br>已识别未回复的列表。<br>质检问题的列表。</p><h2 id="文化云项目"><a href="#文化云项目" class="headerlink" title="文化云项目"></a>文化云项目</h2><ul><li>url视频链接不对。</li></ul><p>解决：url怎么来的，如何判断用户设备，根据用户设备查对应的Url.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后端日志-week2</title>
      <link href="/2024/08/12/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week02/"/>
      <url>/2024/08/12/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week02/</url>
      
        <content type="html"><![CDATA[<h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><h3 id="Nacos的原理和使用"><a href="#Nacos的原理和使用" class="headerlink" title="Nacos的原理和使用"></a>Nacos的原理和使用</h3><p><strong>四大功能：</strong></p><ul><li><strong>服务发现和服务健康监测</strong>：（使服务更容易注册，并通过DNS或HTTP接口发现其他服务，还提供服务的实时健康检查，以防止向不健康的主机或服务实例发送请求。）</li><li><strong>动态配置服务</strong>：（即Nacos即是服务发现中心，又是配置中心，当然配置写在服务本地也可，写在Nacos里可以利用公用配置简化服务配置过程）</li><li><strong>动态DNS服务</strong>：动态 DNS 服务支持权重路由，更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。</li><li><strong>服务及其元数据管理</strong>：管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</li></ul><p><strong>服务发现过程：</strong></p><ol><li><p>在每个服务启动时会向服务发现中心上报自己的网络位置。在服务发现中心内部会形成一个服务注册表，服务注册表是服务发现的核心部分，是包含所有服务实例的网络地址的数据库。</p></li><li><p>服务发现客户端（即每个服务本身）会定期从服务发现中心同步服务注册表 ，并缓存在客户端。</p></li><li><p>当需要对某服务进行请求时，服务实例通过该注册表，定位目标服务网络地址。若目标服务存在多个网络地址，则使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。</p></li></ol><h3 id="如何实现一个需求（以查询课程为例）"><a href="#如何实现一个需求（以查询课程为例）" class="headerlink" title="如何实现一个需求（以查询课程为例）"></a>如何实现一个需求（以查询课程为例）</h3><ol><li><strong>需求分析</strong><br>分析该模块业务流程(以查询课程为例):</li></ol><ul><li>在课程进行列表查询页面输入查询条件查询课程信息</li><li>当不输入查询条件时输入全部课程信息。</li><li>输入查询条件查询符合条件的课程信息。</li><li><strong>约束：</strong>本教学机构查询本机构的课程信息。</li></ul><ol start="2"><li><strong>分析数据模型</strong><br>可以找大模型帮忙分析一下</li></ol><ul><li><p>查询条件：<br>包括：课程名称、课程审核状态、课程发布状态<br>课程名称：可以模糊搜索<br>课程审核状态：未提交、已提交、审核通过、审核未通过<br>课程发布状态：未发布、已发布、已下线<br>因为是分页查询所以查询条件中还要包括当前页码、每页显示记录数。</p></li><li><p>查询结果<br>包括：课程id、课程名称、任务数、创建时间、是否付费、审核状态、类型，操作<br>任务数：该课程所包含的课程计划数，即课程章节数。<br>是否付费：课程包括免费、收费两种。<br>类型：录播、直播。<br>因为是分页查询所以查询结果中还要包括总记录数、当前页、每页显示记录数。</p></li></ul><p><strong>根据以上分析内容创建PO</strong>(与数据库字段对等，使用代码生成器，比如Mybatis-plus的生成器)</p><p>3.接口设计分析</p><ul><li><strong>确定协议：</strong> 通常协议采用HTTP，查询类接口通常为get或post，查询条件较少的使用get，较多的使用post，其他的还有(Put,Delete等，采用RestFul风格)。<strong>确定content-type</strong>：参数以什么数据格式提交，结果以什么数据格式响应。(一般以JSON格式响应)。</li></ul><p><strong>Get和Post异同？</strong></p><p><strong>同：</strong><br>GET&#x2F;POST都是Http请求，都走TCP链接。GET和POST能做的事情是一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的（取决于服务器响应策略）。<br><strong>异：</strong></p><ol><li>直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</li><li>Get参数显示在Url中，安全性较差。Post不显示，安全性较好。</li><li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li></ol><ul><li><p><strong>分析请求参数：（DTO（公司脚手架里的ReqVO），前端给后端的数据）</strong> 主要根据对上述数据模型的分析，请求参数为：课程名称、课程审核状态、当前页码、每页显示记录数。根据分析的请求参数定义模型类。</p></li><li><p><strong>分析响应结果：（RespVO，后端向前端的响应数据）</strong> 根据上述对数据模型的分析，响应结果为数据列表加一些分页信息（总记录数、当前页、每页显示记录数）。数据列表中数据的属性包括：课程id、课程名称、任务数、创建时间、审核状态、类型。</p></li></ul><p>关于为什么需要VO、DTO、PO：<br><img src="/image-8.png" alt="alt text"></p><ul><li>接口中调用Service方法完成业务处理。</li></ul><p><a href="https://blog.csdn.net/jiangyu1013/article/details/83107255">Swagger文档的一些常用注解</a>，仿照项目中脚手架也可以。</p><h2 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h2><h3 id="Mybatis-plus的使用"><a href="#Mybatis-plus的使用" class="headerlink" title="Mybatis-plus的使用"></a>Mybatis-plus的使用</h3><p>Mybatis Plus 对 Mapper 层和 Service 层都将常见的增删改查操作都封装好了，只需简单继承即可，使用时只要注入接口就好</p><h4 id="BaseMapper层"><a href="#BaseMapper层" class="headerlink" title="BaseMapper层"></a><strong>BaseMapper层</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br></pre></td></tr></table></figure><p>在公司脚手架的下段代码中，操作数据库的逻辑都在这个接口里用default方法写。（BaseMapperX是公司封装的MyBatis-plus包，没有封装的情况继承的是BaseMapper），继承于BaseMapper的方法有：userMapper.insert(),select(),delete(),upadate等变体，其中查询语句多与QueryWrapper相关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AdminUserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapperX</span>&lt;AdminUserDO&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> AdminUserDO <span class="title function_">selectByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;AdminUserDO&gt;().eq(AdminUserDO::getUsername, username));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BaseMapper相关查询方法"><a href="#BaseMapper相关查询方法" class="headerlink" title="BaseMapper相关查询方法"></a><strong>BaseMapper相关查询方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 通过 Wrapper 组装查询条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 通过 Wrapper 组装查询条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 来设置条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 组装查询条件，查询全部记录，并以 map 的形式返回</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =========================== 分页相关 ===========================</span></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：<br><code>Collection&lt;? extends Serializable&gt; ：</code> 主键ID列表（不能为Null）</p><h4 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a><strong>Service层</strong></h4><p>定义UserService 接口 ，让其继承自IService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义实现类UserServiceImpl，让其继承自 ServiceImpl, 同时实现 UserService接口，这样就可以让UserService拥有了基础的CRUD功能，当然，实际开发中，业务会更加复杂，就需要向IService接口自定义方法并实现:</p><blockquote><p>在公司脚手架中未见这种实现方式，相关数据库操作似乎只在BaseMapper方式中实现，另外这一类的Service是否能写业务相关的逻辑呢，在xuecheng项目里这一类的Service里都只写CRUD操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;**UserMapper**, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Service层CRUD方法：</strong><br>saveBatch操作都是循环插入，但是MyBatis-plus帮你优化插入性能，内部会将每次的插入语句缓存起来，等到达到 1000 条的时候，才会统一推给数据库。<br>增加数据：save开头，删除remove开头，更新update开头，查询下面详细说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sava(T) : <span class="type">boolean</span></span><br><span class="line"><span class="comment">// 伪批量插入，实际上是通过 for 循环一条一条的插入</span></span><br><span class="line">savaBatch(Collection&lt;T&gt;) : <span class="type">boolean</span></span><br><span class="line"><span class="comment">// 伪批量插入，int 表示批量提交数，默认为 1000</span></span><br><span class="line">savaBatch(Collection&lt;T&gt;, <span class="type">int</span>) : <span class="type">boolean</span></span><br><span class="line"><span class="comment">// 新增或更新(单条数据)</span></span><br><span class="line">saveOrUpdate(T) : <span class="type">boolean</span></span><br><span class="line"><span class="comment">// 批量新增或更新</span></span><br><span class="line">saveOrUpdateBatch(Collection&lt;T&gt;) : <span class="type">boolean</span></span><br><span class="line"><span class="comment">// 批量新增或更新(可指定批量提交数)</span></span><br><span class="line">saveOrUpdateBatch(Collection&lt;T&gt;, <span class="type">int</span>) : <span class="type">boolean</span></span><br></pre></td></tr></table></figure><p>注入UserService进行使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><h4 id="Service相关查询方法"><a href="#Service相关查询方法" class="headerlink" title="Service相关查询方法"></a><strong>Service相关查询方法</strong></h4><ul><li>getXXX : get 开头的方法，用于查询一条数据。</li><li>listXXX : list 开头的方法，用于查询多条数据；</li><li>pageXXX : page 开头的方法，用于分页查询；</li><li>count : 用于查询总记录数；</li></ul><p><strong>分页查询：</strong>（进行分页查询之前需要在MybatisPlusConfig配置类中，添加分页插件 PaginationInnerInterceptor），记得在MyBatisPlusConfig中添加<code>@MapperScan(&quot;com.xxx.xxx.mapper&quot;)</code>注解，告诉MyBatisPlus应该扫描哪里。</p><p><code>BaseMapper</code> 提供的分页查询相关的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页查询，page 用于设置需要查询的页数，以及每页展示数据量，wrapper 用于组装查询条件</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 同上，区别是用 map 来接受查询的数据</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>Wrapper<T></td><td>queryWrapper</td><td>实体对象封装操作类，查询条件</td></tr><tr><td>IPage<T></td><td>page</td><td>分页查询条件，page的相关属性设置条件，如size和Current</td></tr></tbody></table><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组装查询条件，当我想无条件查询的时候，queryWrapper为Null或者不设置条件都可以</span></span><br><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// where age = 30</span></span><br><span class="line">queryWrapper.eq(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询第 2 页数据，每页 10 条</span></span><br><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//或者这样设置 page.setCurrent(2), page.setSize(10);</span></span><br><span class="line"></span><br><span class="line">page = userMapper.selectPage(page, queryWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;总记录数：&quot;</span> + page.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总共多少页：&quot;</span> + page.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;当前页码：&quot;</span> + page.getCurrent());</span><br><span class="line"><span class="comment">// 当前页数据</span></span><br><span class="line">List&lt;User&gt; users = page.getRecords();</span><br></pre></td></tr></table></figure><p><code>Service层</code>封装的相关分页方法（其实与BaseMapper类似,BaseMapper是selectPage()，Service是page()，二者入参类似）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组装查询条件</span></span><br><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// where age = 30</span></span><br><span class="line">queryWrapper.eq(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询第 2 页数据，每页 10 条</span></span><br><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">page = userService.page(page, queryWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;总记录数：&quot;</span> + page.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总共多少页：&quot;</span> + page.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;当前页码：&quot;</span> + page.getCurrent());</span><br><span class="line"><span class="comment">// 当前页数据</span></span><br><span class="line">List&lt;User&gt; users = page.getRecords();</span><br></pre></td></tr></table></figure><h4 id="多表联查（join）："><a href="#多表联查（join）：" class="headerlink" title="多表联查（join）："></a><strong>多表联查（join）：</strong></h4><p><code>UserMapper.xml</code> 中编写关联语句，以及需要映射的对象，内容如下（注：多表联查涉及到xml，所以只用BaseMapper层）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.quanxiaoha.mybatisplusdemo.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.quanxiaoha.mybatisplusdemo.model.OrderVO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userAge&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userGender&quot;</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;goodsName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;goods_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;goodsPrice&quot;</span> <span class="attr">column</span>=<span class="string">&quot;goods_price&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOrders&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderMap&quot;</span>&gt;</span> //selectOrders就是查询方法名</span><br><span class="line">        select o.order_id, o.user_id, o.goods_name, o.goods_price, u.name, u.age, u.gender</span><br><span class="line">        from t_order as o left join  t_user as u on  o.user_id = u.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>关于xml文件的创建：</li></ul><blockquote><p>使用MyBatis-Plus的Generator开发持久层，每张表对应的PO类、Mapper接口、Mapper的xml文件。PO类对应数据库的每张表，每张表需要创建一个Mapper接口和Mapper的xml映射文件 。</p></blockquote><ul><li>关于xml文件的属性：</li></ul><blockquote><p>namespace标签内容&#x3D;“前文BaseMapper接口的包路径名”<br>resultMap、type 标签定义查询语句返回结果集的类型，将实体类字段与数据库表中字段进行关联映射<br>select标签的id为下文使用的方法名，resultMap为上文定义的查询结果类型</p></blockquote><ul><li>创建完了 <code>UserMapper.xml</code>，还要在<code>applicatoin.yml</code> 中添加如下配置，告诉 Mybatis-Plus 框架去扫描这些<code>xml</code>文件：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*Mapper.xml</span> <span class="string">//当放在Resource文件下是这么写</span></span><br></pre></td></tr></table></figure><p>联表查询代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;OrderVO&gt; orderVOS = userMapper.selectOrders(); <span class="comment">//Mapperxml的selectId名</span></span><br></pre></td></tr></table></figure><h4 id="分页联表查询（分页-联表-条件查询）："><a href="#分页联表查询（分页-联表-条件查询）：" class="headerlink" title="分页联表查询（分页+联表+条件查询）："></a>分页联表查询（分页+联表+条件查询）：</h4><p>实际开发场景中，很多<strong>关联查询</strong>都需要结合分页一起使用，假设上面展示的数据需要<strong>分页展示</strong>，<strong>且需要支持条件查询</strong>，要怎么做呢？</p><ul><li>定义关联查询分页方法(同样基于UserMapper层)：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">    IPage&lt;OrderVO&gt; <span class="title function_">selectOrderPage</span><span class="params">(IPage&lt;OrderVO&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> QueryWrapper&lt;OrderVO&gt; wrapper)</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 入参:Mybatis-plus提供的分页类IPage与QueryWrapper （用于组装 where 条件）。</p></blockquote><ul><li>在<code>UserMapper.xml</code>中创建该方法对应的关联查询：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.quanxiaoha.mybatisplusdemo.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.quanxiaoha.mybatisplusdemo.model.OrderVO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userAge&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userGender&quot;</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;goodsName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;goods_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;goodsPrice&quot;</span> <span class="attr">column</span>=<span class="string">&quot;goods_price&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> //...</span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOrderPage&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderMap&quot;</span>&gt;</span></span><br><span class="line">        select u.name, u.age, u.gender, o.order_id, o.goods_name, o.goods_price</span><br><span class="line">        from t_user as u left join t_order as o on u.id = o.user_id</span><br><span class="line">        $&#123;ew.customSqlSegment&#125; //占位符，表示能扩展QueryWrapper的条件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> //...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectOrdersPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询第一页，每页显示 10 条</span></span><br><span class="line">    Page&lt;OrderVO&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 注意：一定要手动关闭 SQL 优化，不然查询总数(Count(*))的时候只会查询主表</span></span><br><span class="line">    page.setOptimizeCountSql(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 组装查询条件 where age = 20</span></span><br><span class="line">    QueryWrapper&lt;OrderVO&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.ge(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    IPage&lt;OrderVO&gt; page1 = userMapper.selectOrderPage(page, queryWrapper);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span> + page1.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;总共多少页：&quot;</span> + page1.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页码：&quot;</span> + page1.getCurrent());</span><br><span class="line">    System.out.println(<span class="string">&quot;查询数据：&quot;</span> + page1.getRecords());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量插入（SQL注入器实现）："><a href="#批量插入（SQL注入器实现）：" class="headerlink" title="批量插入（SQL注入器实现）："></a><strong>批量插入（SQL注入器实现）：</strong></h4><p>MySQL 支持一条 SQL 语句可以批量插入多条记录，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `t_user` (`name`, `age`, `gender`) VALUES (<span class="string">&#x27;ldp01&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="string">&#x27;ldp02&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="string">&#x27;ldp03&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>Mybatis的伪批量插入方法saveBatch()，源码实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取预编译的插入 SQL</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> <span class="built_in">this</span>.getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">        <span class="comment">// for 循环执行 insert</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            sqlSession.insert(sqlStatement, entity);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>[SQL注入器方法]（<a href="https://www.quanxiaoha.com/mybatis-plus/mybatisplus-batch-insert.html%EF%BC%89">https://www.quanxiaoha.com/mybatis-plus/mybatisplus-batch-insert.html）</a></p><p><strong>QueryWrapper构造：</strong><br><a href="https://www.quanxiaoha.com/mybatis-plus/mybaitsplus-wrapper.html">QueryWrapper</a></p><p><strong>常用注解：</strong></p><ul><li>@TableName：作用：表名注解，标识实体类(PO)对应的表。</li><li>@TableId: 作用：主键注解，<code>@TableId(type = IdType.AUTO)</code></li><li>@TableField：作用：指定数据库字段注解（非主键）。</li><li>@TableLogic：作用：逻辑删除注解。</li><li>@Version：作用：乐观锁注解。</li></ul><h2 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h2><h3 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h3><p>在工作中推荐使用GitHub flow协作方式，即不在主仓库的分支上开发，而是<code>fork</code>到自己<code>workspace</code>下。每次开发，需要先<code>checkout</code>一个新的分支，<code>commit</code>之后推送到自己的仓库，再向主仓库提<code>Merge Request</code>。所以开发过程中对于大多数项目来说，都会经过如下步骤：</p><ol><li>Fork</li><li>Create a branch</li><li>Add Commits</li><li>Open a Merge Request</li><li>Code review</li><li>Merge</li><li>Deploy</li></ol><p><strong>流程详解：</strong></p><ol><li><strong>Fork主仓</strong></li></ol><p>项目组长建立代码的主仓库，剩余小组开发人员首先要对其仓库进行Fork。Fork之后，从自己的仓库进行clone，一般来说一个仓库会有几个分支，比如：</p><ul><li><code>master</code>分支为主分支(保护分支)，禁止直接在master上进行修改代码和提交，此分支的代码可以随时被发布到线上。</li><li><code>develop/dev</code>分支为测试分支或者叫做合并分支，所有开发完成需要提交测试的功能合并到该分支，该分支包含最新的更改。</li><li><code>feature</code> 分支为开发分支，大家根据不同需求创建独立的功能分支，开发完成后合并到develop分支；</li><li><code>fix</code> 分支为bug修复分支，需要根据实际情况对已发布的版本进行漏洞修复；<br>一般而言，有master分支和dev分支便可。</li></ul><ol start="2"><li><strong>添加远程仓库</strong></li></ol><p>首先我们需要把远程主仓库给添加进来，方便以后push和pull，例如将项目组长所建立的主仓库添加进来：（upstream是远程仓库的代称，可随意命名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add upstream ssh://主仓库地址</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  ssh://git@gitlab.xxx.cn:8022/aaa/xxx.git (fetch)   <span class="comment">#自己的</span></span><br><span class="line">origin  ssh://git@gitlab.xxx.cn:8022/aaa/xxx.git (push)    <span class="comment">#自己的</span></span><br><span class="line">upstream        ssh://git@gitlab.xxx.cn:8022/aaa/xxx.git (fetch)    <span class="comment">#项目组长的</span></span><br><span class="line">upstream        ssh://git@gitlab.xxx.cn:8022/aaa/xxx.git (push)     <span class="comment">#项目组长的</span></span><br></pre></td></tr></table></figure><p>之后可以通过以下方式push和pull代码，切记不要push主仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin HEAD:分支</span><br><span class="line">git pull upstream develop // 每天开发之前pull一下</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>查看分支和状态</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="comment">#查看本地分支</span></span><br><span class="line">git branch -a <span class="comment">#查看远程分支</span></span><br><span class="line">git status <span class="comment">#查看git状态</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>开始工作新建分支</strong><br>不要一股脑的在develop分支上直接开发功能，先打开git bash，先pull一下主仓库保证代码最新，之后先新建一个分支。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名 //新建分支名并进入该分支</span><br><span class="line">git checkout 分支名 //切换到现有分支</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>提交代码</strong><br>主仓库的更新速度比你写代码快，也就是说很多情况主仓库的代码都是要比你的新，所以你要先<code>pull</code>主仓库的代码进行更新，但是直接Pull的话也许会产生冲突，需要你将代码放入暂存区Stash进行保管</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">&quot;msg&quot;</span> //保存你的代码</span><br><span class="line">git pull upstream master //更新你的代码</span><br></pre></td></tr></table></figure><p>更新完代码之后，你需要将之前存储在暂存区的代码进行恢复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash list   <span class="comment">#查看stash了哪些存储</span></span><br><span class="line">git stash show   <span class="comment">#显示做了哪些改动</span></span><br><span class="line">git stash apply  <span class="comment">#将某个暂存取出，git stash apply stash@&#123;$num&#125;</span></span><br><span class="line">git stash drop stash@&#123;<span class="variable">$num</span>&#125;  <span class="comment">#丢弃stash@&#123;$num&#125;存储，从列表中删除这个存储</span></span><br><span class="line">git stash clear <span class="comment">#删除所有缓存的stash</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>commit并且push</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff //用于查看修改的文件</span><br><span class="line">git add . //add全部修改内容到暂存区</span><br><span class="line">git commit -m <span class="string">&quot;msg&quot;</span> //提交更改</span><br><span class="line">git push origin HEAD:分支名 //记住，这一步是push到自己的远程仓库</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>提PR（Pull Request）</strong><br>到自己的远程仓库里，向主仓库提交分支合并请求，一般是自己这次工作创建的分支合并到主仓库的develop分支，然后选择代码审查人员进行CodeReview。</li></ol><h2 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h2><h3 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h3><h4 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a><a href="https://cloud.tencent.com/developer/article/2393736">docker命令</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker images <span class="comment">#查看镜像</span></span><br><span class="line">docker pull &lt;镜像名:tag&gt; <span class="comment">#下载镜像并指定版本</span></span><br><span class="line">docker run --name webserver -p 80:80  -d nginx <span class="comment">#运行镜像并指定端口-p，后台运行-d</span></span><br><span class="line">docker ps <span class="comment">#查看当前运行的容器</span></span><br><span class="line">docker save -o nginx_latest.tar nginx:latest  <span class="comment">#将镜像保存为tar文件</span></span><br><span class="line">docker load --input nginx_latest.tar <span class="comment">#将保存的tar文件加载为镜像</span></span><br><span class="line">docke search nginx  <span class="comment">#在Docker Hub上搜索镜像</span></span><br><span class="line">docker rmi &lt;镜像名/镜像ID&gt; <span class="comment">#删除指定的镜像</span></span><br><span class="line">docker rmi -f &lt;镜像名/镜像ID&gt; <span class="comment">#强制删除指定的镜像</span></span><br><span class="line"></span><br><span class="line">docker stop &lt;容器ID/name&gt; <span class="comment">#停止运行指定ID的容器</span></span><br><span class="line">docker start &lt;容器ID/name&gt; <span class="comment">#开始运行指定ID的容器</span></span><br><span class="line">docker restart &lt;容器ID/name&gt; <span class="comment">#重启指定的容器</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;容器ID/name&gt; <span class="comment">#删除指定的容器，不能是正在运行的</span></span><br><span class="line">docker logs -f --<span class="built_in">tail</span>=20 &lt;容器名&gt; <span class="comment">#查看末尾20行日志</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器ID/name&gt; bash  <span class="comment">#进入正在运行的容器进行交互，交互逻辑和Linux类似，但是没有编辑器，这就是容器与数据耦合带来的结果</span></span><br><span class="line">docker <span class="built_in">exit</span>  <span class="comment">#在容器内部退出</span></span><br><span class="line"></span><br><span class="line">ctrl+p/ctrl+q  <span class="comment">#退出容器，保持运行状态</span></span><br></pre></td></tr></table></figure><h4 id="为了将容器内数据与容器解耦合，需要数据卷："><a href="#为了将容器内数据与容器解耦合，需要数据卷：" class="headerlink" title="为了将容器内数据与容器解耦合，需要数据卷："></a><strong>为了将容器内数据与容器解耦合，需要数据卷：</strong></h4><p>数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录</p><ul><li>可供容器使用的特殊目录，可以在容器之间共享和重用</li><li>对数据卷的修改会立即生效，对数据卷的更新 不会影响镜像</li><li>卷会一直存在，直到没有容器使用</li></ul><p>在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v /data/webserver:/usr/share/nginx/html nginx <span class="comment">#将主机的/data/webserver挂载到容器的/usr/share/nginx/html目录</span></span><br></pre></td></tr></table></figure><p>docker volume [COMMAND]命令用于管理Docker数据卷：</p><ul><li>create  volumeName  创建一个volume，一般关联宿主机&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;目录下</li><li>inspect volumeName  显示一个或多个volume的信息</li><li>ls 列出所有volume</li><li>prune  删除未使用的volume</li><li>rm  volumeName  移除一个volume</li></ul><p>示例，创建并运行一个MySQL容器，将宿主机目录直接挂载到容器：</p><ol><li>通过docker pull mysql:5.7.25 拉取mysql镜像 </li><li>创建目录&#x2F;tmp&#x2F;mysql&#x2F;data</li><li>创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，并在该目录下新建文件hmy.cnf，写入如下内容，或者（docker volume create html，比如挂载nginx）</li><li>-v <strong>宿主机目录:容器内目录</strong>，</li><li>-v <strong>宿主机文件:容器内文件</strong>，</li><li>-v <strong>volume名称:容器内目录</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">character_set_server=utf8</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">server-id=1000</span><br></pre></td></tr></table></figure><ol start="4"><li>将上述创建的目录挂载到mysql容器内部</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123</span><br><span class="line">-p 3307:3306</span><br><span class="line">-v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf </span><br><span class="line">-v /tmp/mysql/data:/var/lib/mysql</span><br><span class="line">-d mysql:5.7.25</span><br></pre></td></tr></table></figure><h3 id="ApiFox的使用"><a href="#ApiFox的使用" class="headerlink" title="ApiFox的使用"></a>ApiFox的使用</h3><p>看ApiFox的官方文档即可。</p><h2 id="day05"><a href="#day05" class="headerlink" title="day05"></a>day05</h2><blockquote><p>tips:@ApiModelProperty不生效时，将POJO中属性字段名改为小写的就好。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后端日志-week1</title>
      <link href="/2024/08/01/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week01/"/>
      <url>/2024/08/01/%E5%90%8E%E7%AB%AF%E6%97%A5%E5%BF%97week01/</url>
      
        <content type="html"><![CDATA[<h2 id="工作日志-后端"><a href="#工作日志-后端" class="headerlink" title="工作日志-后端"></a>工作日志-后端</h2><h3 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h3><p>今天完成脚手架框架的搭建，RabbitMQ的访问端口要写成5672,15672只是管理页面的进入方式，并非配置端口。</p><h3 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h3><h4 id="OAuth2认证服务的配置"><a href="#OAuth2认证服务的配置" class="headerlink" title="OAuth2认证服务的配置"></a>OAuth2认证服务的配置</h4><ol><li>需要配置 <strong>public class AuthorizationServer extends AuthorizationServerConfigurerAdapter{}</strong> 中的三个类</li></ol><blockquote><ul><li><strong>AuthorizationServerSecurityConfigurer</strong>：用来配置令牌端点(Token Endpoint)的安全约束。</li><li><strong>ClientDetailsServiceConfigurer</strong>：用来配置客户端详情服务（ClientDetailsService），客户端详情信息在这里进行初始化，你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息。（比如clientid等，用以识别客户端身份）（一般有内存形式和）</li><li><strong>AuthorizationServerEndpointsConfigurer</strong>：用来配置授权（authorization）以及令牌（token）的访问端点和令牌服务(token services)。</li></ul></blockquote><ol start="2"><li>配置AuthorizationServerTokenServices tokenService类，设定令牌有效期等令牌配置。</li></ol><h4 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h4><ol><li>Redis将所有数据存储在内存中，这使得它能够提供非常快速的读写操作。</li><li>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。（采用单线程模型，避免多线程之间的竞争，单线程模型说明请看小林Coding）<br>Redis 在 2.0 版本，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；<br>Redis 在 4.0 版本之后，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。</li><li>Redis采用I&#x2F;O多路复用机制处理Socket请求，而不是阻塞等待请求完成，这种架构使得Redis能够高效地处理大量并发连接。</li><li>redis高效的数据结构设计，比如在ZSet中使用跳表、压缩列表这样的数据结构。</li></ol><blockquote><p>跳表（skiplists）是一种有序的数据结构，它通过在每个节点中维持多个指向其他的节点指针，从而达到快速访问队尾目的。</p></blockquote><blockquote><p>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p></blockquote><p><img src="/image-1.png" alt="alt text"></p><h4 id="StringRedisTemplate的相关操作"><a href="#StringRedisTemplate的相关操作" class="headerlink" title="StringRedisTemplate的相关操作"></a>StringRedisTemplate的相关操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringRedisTemplate.opsForValue();　　<span class="comment">//操作字符串</span></span><br><span class="line">StringRedisTemplate.opsForHash();　　 <span class="comment">//操作hash</span></span><br><span class="line">StringRedisTemplate.opsForList();　　 <span class="comment">//操作list</span></span><br><span class="line">StringRedisTemplate.opsForSet();　　  <span class="comment">//操作set</span></span><br><span class="line">StringRedisTemplate.opsForZSet();　 　<span class="comment">//操作有序set</span></span><br></pre></td></tr></table></figure><h4 id="Redis缓存雪崩、击穿、穿透"><a href="#Redis缓存雪崩、击穿、穿透" class="headerlink" title="Redis缓存雪崩、击穿、穿透"></a>Redis缓存雪崩、击穿、穿透</h4><p>布隆过滤器通过添加的key需要根据k个无偏hash函数（一般是三个）计算得到多个hash值，然后对数组长度进行取模得到数组下标的位置，然后将对应数组下标的位置的值置为1，当有新元素进来时，只要通过hash计算的位置有一个为1则判断其已经存在于Redis中。<br>布隆过滤器判断存在则不一定存在，判断不存在则一定不存在。布隆过滤器有时候占太大内存，需要清空或者重新设置。</p><p><img src="/image.png" alt="alt text"></p><h4 id="Redis与数据库一致性问题"><a href="#Redis与数据库一致性问题" class="headerlink" title="Redis与数据库一致性问题"></a>Redis与数据库一致性问题</h4><p>(一般给缓存添加过期时间)<br>先删缓存，再更新数据库：采用延时双删除解决不一致问题<br><strong>先更新数据库，再更新缓存</strong>（主流，Cache-aside）<br>消息队列重试机制，应用消息队列删除缓存时：</p><ul><li>如果应用删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存。</li><li>如果删除缓存成功，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul><h5 id="应用Cannal订阅MysqlBinlog删除缓存"><a href="#应用Cannal订阅MysqlBinlog删除缓存" class="headerlink" title="应用Cannal订阅MysqlBinlog删除缓存"></a>应用Cannal订阅MysqlBinlog删除缓存</h5><p>Cannal是什么：</p><p>可以简单地把canal理解为一个用来同步<strong>MySQL增量数据</strong>（不同步全量数据）的一个工具，将增量数据同步给消息队列、缓存、搜索引擎（ElasticSearch）等。</p><p>Canal简单原理：<br>Canal模拟Mysql的主从复制的交互协议，把自己伪装成一个Mysql的从节点，向Mysql主节点发送dump请求，Mysql接受请求后就会推送Binlog给Canal，Canal解析Binlog字节流之后会将其转换为便于读取的结构化数据，供下游程序订阅使用。</p><p>数据一致性做法：<br>这里采用的是先更新数据库后更新缓存的策略，所以当数据库数据发生变更时，将binlog日志采集发送到MQ队列里面，然后编写一个简单的缓存删除消息者订阅binlog日志，根据更新log删除缓存，并且通过ACK机制确认处理这条更新log，保证数据缓存一致性。<strong>（必须删除缓存成功后再ACK给消息队列）</strong></p><h3 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h3><p><strong>@AllArgsConstructor</strong> 是 Lombok 库的一个注解，它用于生成一个包含所有参数的构造函数。这个注解通常与@NoArgsConstructor 一起使用，后者用于生成一个不包含任何参数的构造函数。</p><p><strong>@Builder</strong> 是 Lombok 库的一个注解，它用于生成一个构建器（Builder）模式，用于简化对象创建的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.builder()</span><br><span class="line">    .name(<span class="string">&quot;John Doe&quot;</span>)</span><br><span class="line">    .age(<span class="number">30</span>)</span><br><span class="line">    .email(<span class="string">&quot;john.doe@example.com&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在后端微服务项目中，字典数据到底是什么？</p><blockquote><p>字典数据（Dictionary Data）通常指的是存储在数据库或内存中的键值对集合，用于存储和提供对应用程序中常用术语、值或选项的统一引用。这些术语、值或选项在应用程序的不同部分被重复使用，例如，国家、省份、性别、产品类型等。</p></blockquote><p>字典数据一般存放在两张表中：</p><ul><li>sys_dict_type: 存储有哪些下拉框，比如用户性别，操作类型等。</li><li>sys_dict_data: 存储下拉框具体option的内容，比如性别男女，会有一列属性与dict-type对应。</li></ul><h3 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h3><p><a href="https://blog.csdn.net/itigoitie/article/details/127785659">https://blog.csdn.net/itigoitie/article/details/127785659</a></p><h4 id="分布式事务概念"><a href="#分布式事务概念" class="headerlink" title="分布式事务概念"></a>分布式事务概念</h4><p>不同服务需要网络通信，而网络存在不可到达性，这种分布式系统环境下，通过与不同的服务进行网络通信去完成事务称之为分布式事务。</p><h4 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h4><p>满足CAP理论，CAP是Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性、分区容忍性。在分布式系统中进行分布式事务控制，要么保证CP、要么保证AP。</p><ol><li><p>CP架构（刚性事务）：如果要满足数据的强一致性，就必须在一个服务数据库锁定的同时，对分布式服务下的其他服务数据资源同时锁定。等待全部服务处理完业务，才可以释放资源。此时如果有其他请求想要操作被锁定的资源就会被阻塞，这样就是满足了CP。达到了强一致性和弱可用性。</p></li><li><p>AP架构（柔性事务）：如果要满足服务的的强可用性，每个服务就可以各自独立执行本地事务，而无需相互锁定其他服务的资源。在各个服务的事务尚未完全处理完毕时，如果去访问数据库，可能会遇到各个节点数据不一致的情况。然后我们还需要一些措施，使得经过一段时间后，各个节点的数据最终达到一致性。这样就是满足了AP。达到了弱一致性（最终一致性）和强可用性。<strong>（保障 AP 放弃 CP 是常见的一种做法）</strong></p></li></ol><h5 id="满足CP的方案"><a href="#满足CP的方案" class="headerlink" title="满足CP的方案"></a>满足CP的方案</h5><p>二阶段提交（Two-Phase Commit，2PC）</p><h5 id="满足AP的方案"><a href="#满足AP的方案" class="headerlink" title="满足AP的方案"></a>满足AP的方案</h5><h6 id="1-TCC模式可以解决2PC中的资源锁定和阻塞问题，减少资源锁定时间。"><a href="#1-TCC模式可以解决2PC中的资源锁定和阻塞问题，减少资源锁定时间。" class="headerlink" title="1. TCC模式可以解决2PC中的资源锁定和阻塞问题，减少资源锁定时间。"></a>1. TCC模式可以解决2PC中的资源锁定和阻塞问题，减少资源锁定时间。</h6><blockquote><p>Try：资源的检测和预留；<br>Confirm：执行的业务操作提交；要求 Try 成功 Confirm 一定要能成功；<br>Cancel：预留资源释放。</p></blockquote><h6 id="2-MQ事务消息方案（消息通知型，采用确认机制"><a href="#2-MQ事务消息方案（消息通知型，采用确认机制" class="headerlink" title="2. MQ事务消息方案（消息通知型，采用确认机制"></a>2. MQ事务消息方案（消息通知型，采用确认机制</h6><blockquote><p>事务发起者A执行本地事务；<br>事务发起者A通过MQ将需要执行的事务信息发送给事务参与者B；<br>事务参与者B接收到消息后执行本地事务；</p></blockquote><p>注意事项：</p><ul><li>事务发起者A必须确保本地事务成功后，消息一定发送成功；</li><li>MQ必须保证消息正确投递和持久化保存；</li><li>事务参与者B必须确保消息最终一定能消费，如果失败需要多次重试；</li><li>事务B执行失败，会重试，但不会导致事务A回滚；</li></ul><h5 id="3-本地消息表方案（消息通知型）"><a href="#3-本地消息表方案（消息通知型）" class="headerlink" title="3. 本地消息表方案（消息通知型）"></a>3. 本地消息表方案（消息通知型）</h5><p>事务发起者：</p><ul><li>开启本地事务；</li><li>执行事务相关业务；</li><li>发送消息到MQ；</li><li>把消息持久化到数据库，标记为已发送；</li><li>提交本地事务；</li></ul><p>事务消费者：</p><ul><li>接收消息；</li><li>开启本地事务；</li><li>修改数据库消息状态为已消费；</li><li>提交本地事务</li></ul><p>开启额外的定时任务（xxl-job）：</p><ul><li>定时扫描消息表中超时未消费消息</li></ul><p>注意事项：</p><ul><li>数据一致性完全依赖于消息服务，因此消息服务必须是可靠的；</li><li>需要处理被动业务方的<strong>幂等问题</strong>；</li><li>被动业务失败不会导致主动业务的回滚，而是重试被动的业务；</li><li>事务业务与消息发送业务耦合、业务数据与消息表要在一起；</li><li>准备阶段（try）：资源的检测和预留；</li><li>执行阶段（confirm&#x2F;cancel）：根据上一步结果，判断下面的执行方法。如果上一步中所有事务参与者都成功，则这里执行confirm。反之，执行cancel；<br><strong>消息幂等性</strong>：即使多次收到了消息，也不会重复消费。所以保证消息的幂等性就是保证消息不会重复消费。</li></ul><p>保证消息幂等性的方法：</p><ol><li>mq内部可以为每条消息生成一个全局唯一、与业务无关的消息id，当mq接收到消息时，会先根据该id判断消息是否重复发送，mq再决定是否接收该消息。</li><li>如果从MQ拿到数据是要存到数据库（Mysql或者Redis中的Set），那么可以根据数据创建唯一约束，这样的话，同样的数据从MQ发送过来之后，当插入数据库的时候，会报违反唯一约束，不会插入成功的。（或者可以先查一次，是否在数据库中已经保存了，如果能查到，那就直接丢弃就好了）。</li></ol><p><strong>本地消息表方案优化版：</strong> 引入一个独立的消息服务，来完成对消息的持久化、发送、确认、失败重试等一系列行为，但是实现会比较复杂。</p><h5 id="4-AT模式（SeaTa）"><a href="#4-AT模式（SeaTa）" class="headerlink" title="4. AT模式（SeaTa）"></a>4. AT模式（SeaTa）</h5><blockquote><p>AT 模式是一种无侵入的分布式事务解决方案。可以看做是对TCC或者二阶段提交模型的一种优化，解决了TCC模式中的代码侵入、编码复杂等问题。</p></blockquote><p>在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。</p><p>基本原理：</p><ul><li>一阶段：执行本地事务，并返回执行结果</li><li>二阶段：根据一阶段的结果，判断二阶段做法：提交或回滚<br>但AT模式底层做的事情可完全不同，而且第二阶段根本不需要我们编写，全部有Seata自己实现了。也就是说：我们写的代码与本地事务时代码一样，无需手动处理分布式事务。</li></ul><p><strong>@Valid注解和VO的联动</strong></p><p>在VO实体中可以加入如下图中的类似@Length、@Pattern之类的注解，这样在Controller传参时加入@Valid注解就可以自动校验参数是否合法。</p><h3 id="day05"><a href="#day05" class="headerlink" title="day05"></a>day05</h3><p>学习Feign之前先学习Ribbon，<strong>Feign是整合了Ribbon做负载均衡</strong>的(很多微服务组件都整合了Ribbon，比如Nacos-Discovery服务)。</p><p><strong>Ribbon:</strong></p><p>负载均衡是从多个服务中根据某个策略选择一个进行访问，常见的负载均衡分为两种:</p><ol><li>客户端负载均衡：即在客户端就进行负载均衡算法分配。例如spring cloud中的ribbon，客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选择 一个服务器，然后进行访问</li><li>服务端负载均衡：在消费者和服务提供方中间使用独立的代理方式进行负载。例如Nginx，先发送请求，然后通过Nginx的负载均衡算法，在多个服务器之间选择一 个进行访问！</li></ol><p>使用Ribbon时只需添加**@LoadBalanced注解**即可。</p><p>Ribbon可以把微服务的服务名通过负载均衡策略替换成某一台机器的IP地址，然后通过http请求进行访问！<strong>（服务名-&gt;ip地址）</strong></p><p><strong>常见的负载均衡算法</strong>：</p><ul><li>随机：通过随机选择服务进行执行，一般这种方式使用较少;</li><li>轮询：请求来之后排队处理，轮着来</li><li>加权轮询：通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个服务器的压力;</li><li>一致性hash：通过客户端请求的地址的HASH值取模映射进行服务器调度。</li><li>最少并发：将请求分配到当前压力最小的服务器上</li><li>Ribbon默认的负载均衡算法：ZoneAvoidanceRule：区域权重策略。默认的负载均衡策略，综合判断server所在区域的性能和server的可用性，轮询选择server并且判断一个AWS Zone的运行性能是否可用，剔除不可用的Zone中的所有server。在没有区域的环境下，类似于轮询(RandomRule)</li></ul><p>自定义负载均衡策略方式有多种：</p><ul><li>实现 IRule 接口</li><li>继承AbstractLoadBalancerRule类</li></ul><p><strong>Feign：</strong></p><p><strong>Feign和OpenFeign区别：</strong></p><ul><li>Feign：Feign是Netflix开发的声明式、模板化的HTTP客户端，Feign可帮助我们更加便捷、优雅地调用HTTP API。可以单独使用</li><li>OpenFeign：Spring Cloud openfeign对Feign进行了 增强，使其支持Spring MVC注解，另外还整合了Ribbon和Eureka，从而使得Feign的使用更加方便。</li></ul><p><strong>Feign常用配置：</strong></p><ul><li>日志配置：有时候我们遇到 Bug，比如接口调用失败、参数没收到等问题，或者想看看调用性能，就需要配置 Feign 的 日志了，以此让 Feign 把请求信息输出来。日志配置分为局部配置和全局配置！</li><li>拦截器配置：每次 feign 发起http调用之前，会去执行拦截器中的逻辑，就类似mvc中的拦截器。比如：做权限认证。</li><li>超时时间配置：通过 Options 可以配置连接超时时间（默认2秒）和读取超时时间（默认5秒），注意：Feign的底层用的是Ribbon，但超时时间以Feign配置为准</li></ul><p>Feign在Ribbon基础上进一步把参数组装到url中去，实现一个完整的RPC调用。</p><blockquote><p>各微服务提供给别的服务调用的接口url要加上服务名，即：Nacos配置文件中的Spring-Application-name&#x2F;xxx(GetMapping(“”))&#x2F;xxx</p></blockquote><p><strong>FeignClient使用：</strong></p><p>下面的例子：比如我的content微服务想要调用Search服务，就在content微服务的包下面</p><p><img src="/feigin.png" alt="alt text"></p><p><strong>SpringGateway的作用</strong>：</p><p>各微服务首先要在Nacos中被发现。</p><ul><li><a href="https://blog.csdn.net/weixin_44863237/article/details/134728229">网关中的一些过滤器、断言与黑白名单设置</a></li><li><a href="https://blog.csdn.net/weixin_32196893/article/details/118962766">网关的一些简要配置与说明，一般情况看这个</a></li></ul><p><img src="/image-7.png" alt="alt text"></p><ul><li>如果不配置网关:<br><img src="/image-6.png" alt="alt text"></li></ul><p><strong>Captcha-Plus(AJ-Captcha)的使用:</strong></p><ol><li><a href="https://blog.csdn.net/zhishidi/article/details/122969872">源码解读</a></li><li>脚手架中继承一下，因为管理使用 &#x2F;admin-api&#x2F;system-user&#x2F;* 作为前缀，所以需要继承（Url问题）</li><li>如下图，获取验证码与校验验证码（Get&#x2F;Check）<br><img src="/image-5.png" alt="alt text"></li><li>二次校验(需要自己进行二次验证签名，需要传captchaVerification)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseModel <span class="title function_">get</span><span class="params">(<span class="meta">@RequestParam(&quot;captchaVerification&quot;)</span> String captchaVerification)</span> &#123;</span><br><span class="line">        <span class="type">CaptchaVO</span> <span class="variable">captchaVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaptchaVO</span>();</span><br><span class="line">        captchaVO.setCaptchaVerification(captchaVerification);</span><br><span class="line">        <span class="type">ResponseModel</span> <span class="variable">response</span> <span class="operator">=</span> captchaService.verification(captchaVO);</span><br><span class="line">        <span class="keyword">if</span>(response.isSuccess() == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">//验证码校验失败，返回信息告诉前端</span></span><br><span class="line">            <span class="comment">//repCode  0000  无异常，代表成功</span></span><br><span class="line">            <span class="comment">//repCode  9999  服务器内部异常</span></span><br><span class="line">            <span class="comment">//repCode  0011  参数不能为空</span></span><br><span class="line">            <span class="comment">//repCode  6110  验证码已失效，请重新获取</span></span><br><span class="line">            <span class="comment">//repCode  6111  验证失败</span></span><br><span class="line">            <span class="comment">//repCode  6112  获取验证码失败,请联系管理员</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//自己的业务代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>工作日志-大模型</title>
      <link href="/2024/07/31/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%97%A5%E5%BF%97week01/"/>
      <url>/2024/07/31/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%97%A5%E5%BF%97week01/</url>
      
        <content type="html"><![CDATA[<ul><li><input disabled="" type="checkbox"> 了解当下大语言模型</li><li><input disabled="" type="checkbox"> 完成大模型部署，掌握大模型训练微调和推理</li><li><input disabled="" type="checkbox"> Python学习，Numpy与Pandas等数据处理，Pytorch与MindSpore框架学习</li><li><input disabled="" type="checkbox"> 掌握prompt提示词工程以提高大模型交互质量</li><li><input disabled="" type="checkbox"> 了解大模型开发工具（LangChain）</li><li><input disabled="" type="checkbox"> 大模型多模态功能，文生图&#x2F;视觉语言模型&#x2F;视频等项目</li><li><input disabled="" type="checkbox"> 多模态大模型的部署，训练，推理</li><li><input disabled="" type="checkbox"> 大模型的优化技巧，如减少模型大小，硬件加速，并行处理等</li><li><input disabled="" type="checkbox"> 大模型的量化方法</li><li><input disabled="" type="checkbox"> 部署在华为昇腾服务器上与ARM服务器相关部署</li><li><input disabled="" type="checkbox"> Arm服务器相关部署</li><li><input disabled="" type="checkbox"> 掌握调用Agent功能及其开发流程，独立开发Agent功能</li></ul><h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><p><strong>大模型相关的参数调整：</strong><br><img src="/image-2.png" alt="alt text"><br><img src="/image-3.png" alt="alt text"></p><p><strong>相关调参方法，涉及到大模型生成答案的策略：</strong></p><p><a href="https://blog.csdn.net/u014403221/article/details/132379801">文本解码策略</a></p><ol><li>当 num_beams&#x3D;1 而且 do_sample&#x3D;False 时，，每个step生成条件概率最高的词，因此生成单条文本。代码中，调用 greedy_search()方法</li><li>随机贪婪搜索：当 num_beams&#x3D;1 且 do_sample&#x3D;True 时，每个单步时会根据模型输出的概率进行采用，而不是选条件概率最高的词，增加多样性。调用 sample() 方法</li><li>贪婪柱搜索：当 num_beams&gt;1 且 do_sample&#x3D;False 时，做一个 num_beams的柱搜索，每次都是贪婪选择top N个柱。调用 beam_search() 方法</li><li>采样柱搜索：当 num_beams&gt;1 且 do_sample&#x3D;True 时，相当于每次不再是贪婪选择top N个柱，而是加了一些采样。调用 beam_sample() 方法</li><li>多组柱搜索搜索：当 num_beams&gt;1 且 num_beam_groups&gt;1 时，多组柱搜索同时进行，最后返回num_beam_groups个结果。调用 group_beam_search() 方法</li></ol><h2 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h2><blockquote><p>tips: AnythingLLM-外挂知识库，能够直接将文档转化为向量存储和聊天平台兼容的数据。</p></blockquote><h3 id="语言模型的适应：从语言模型到任务模型的转换"><a href="#语言模型的适应：从语言模型到任务模型的转换" class="headerlink" title="语言模型的适应：从语言模型到任务模型的转换"></a>语言模型的适应：从语言模型到任务模型的转换</h3><p><strong>两种方式让语言模型进行适应：</strong></p><ol><li>训练（标准的有监督学习）：训练一个新模型，使其能将输入映射到输出。这可以通过创建一个新模型并利用语言模型作为特征（探针法），或者从现有的语言模型出发，根据训练实例进行更新（微调），或者在这两者之间找到平衡（轻量级的微调）。</li><li>提示（上下文）学习：根据对任务的描述建一个或一组提示&#x2F;上下文信息，将其输入到语言模型中以获取基于该任务的生成结果。根据提示&#x2F;上下文信息的数量，我们还可以进一步细分：</li></ol><ul><li>零样本学习(Zero-shot)：提示&#x2F;上下文信息的数量为0，模型直接基于对任务的理解输出结果。</li><li>单样本学习(One-shot)：提示&#x2F;上下文信息的数量为1，一般来说模型基于1个例子可以更好的理解任务从而较好的生成结果。</li><li>少样本学习(Few-shot)：提示&#x2F;上下文信息的数量大于1，大模型可以看到更丰富的例子，一般来说获得比单样本学习更好的效果。</li><li>提示的局限性：Transformer只接受2048以下个tokens输入，可以以QA的形式进行问答。</li></ul><h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><blockquote><p>Tips 词元(token)一般在NLP（自然语言处理）中来说，通常指的是一个文本序列中的最小单元，可以是单词、标点符号、数字、符号或其他类型的语言元素。通常，对于NLP任务，文本序列会被分解为一系列的tokens，以便进行分析、理解或处理。在英文中一个”token”可以是一个单词，也可以是一个标点符号。在中文中，通常以字或词作为token</p></blockquote><ul><li>BPE分词器算法，步骤：</li><li>Input(输入)：训练语料库（字符序列）。<br>算法步骤</li><li>Step1. 初始化词汇表 $V$ 为字符的集合。</li><li>while(当我们仍然希望V继续增长时)：<br>Step2. 找到$V$中共同出现次数最多的元素对 $x,x’$ 。</li><li>Step3. 用一个新的符号 $xx’$ 替换所有 $x,x’$ 的出现。</li><li>Step4. 将$xx’$ 添加到V中</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安装环境踩坑</title>
      <link href="/2024/07/10/%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/07/10/%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="在Windows环境下安装Docker-DeskTop"><a href="#在Windows环境下安装Docker-DeskTop" class="headerlink" title="在Windows环境下安装Docker DeskTop"></a>在Windows环境下安装Docker DeskTop</h2><p>今天完成了WIndows环境下的docker安装，docker其实在Linux环境下安装更方便，在Win11&#x2F;Win10环境下安装首先要准备操作系统的虚拟环境。</p><h3 id="安装Hyper-v"><a href="#安装Hyper-v" class="headerlink" title="安装Hyper-v"></a>安装Hyper-v</h3><p>需要再控制面板的系统界面中将以下服务打开，如果没有hyper-v选项的，可以运行以下代码。</p><blockquote><p><img src="/hj1.png" alt="alt text"><br><img src="/hj2.png" alt="alt text"></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pushd</span> <span class="string">&quot;%~dp0&quot;</span></span><br><span class="line"><span class="built_in">dir</span> /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hv.txt</span><br><span class="line"><span class="keyword">for</span> /f %%i <span class="keyword">in</span> (<span class="string">&#x27;findstr /i . hv.txt 2^&gt;nul&#x27;</span>) <span class="keyword">do</span> dism /online /norestart /add-package:<span class="string">&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span></span><br><span class="line">del hv.txt</span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V -All /LimitAccess /ALL</span><br><span class="line">Pause</span><br></pre></td></tr></table></figure><p>确认打开之后，再下载安装<a href="https://link.csdn.net/?target=https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">wsl更新包</a>，安装完成后成功运行docker-desktop，其中电脑会重启几次设置Linux环境，另外，如果想在Win上安装Linux子系统的话也是可以的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
